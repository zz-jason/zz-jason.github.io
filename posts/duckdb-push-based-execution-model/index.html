<!doctype html><html lang=en dir=ltr class=scroll-smooth data-default-appearance=dark data-auto-appearance=true><head><meta charset=utf-8><meta http-equiv=content-language content="en"><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=x-ua-compatible content="ie=edge"><title>[DuckDB] Push-Based Execution Model &#183; Jian Zhang</title><meta name=title content="[DuckDB] Push-Based Execution Model &#183; Jian Zhang"><meta name=description content="My personal blog"><link rel=canonical href=https://zz-jason.github.io/posts/duckdb-push-based-execution-model/><link type=text/css rel=stylesheet href=/css/main.bundle.min.c6116b9ed1c907a8c0eb015f377d3eecc07e448d75729e31fc3de5881465c6c172ba9fa9a6800c030116caf2a110d92242bb816639484ca791f7cd107a8d49b5.css integrity="sha512-xhFrntHJB6jA6wFfN30+7MB+RI11cp4x/D3liBRlxsFyup+ppoAMAwEWyvKhENkiQruBZjlITKeR980Qeo1JtQ=="><script type=text/javascript src=/js/appearance.min.516a16745bea5a9bd011138d254cc0fd3973cd55ce6e15f3dec763e7c7c2c7448f8fe7b54cca811cb821b0c7e12cd161caace1dd794ac3d34d40937cbcc9ee12.js integrity="sha512-UWoWdFvqWpvQERONJUzA/TlzzVXObhXz3sdj58fCx0SPj+e1TMqBHLghsMfhLNFhyqzh3XlKw9NNQJN8vMnuEg=="></script>
<script src=/js/zoom.min.js></script>
<link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest><meta property="og:title" content="[DuckDB] Push-Based Execution Model"><meta property="og:description" content="1."><meta property="og:type" content="article"><meta property="og:url" content="https://zz-jason.github.io/posts/duckdb-push-based-execution-model/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-11-14T08:36:00+08:00"><meta property="article:modified_time" content="2022-11-14T08:36:00+08:00"><meta property="og:site_name" content="Jian Zhang"><meta name=twitter:card content="summary"><meta name=twitter:title content="[DuckDB] Push-Based Execution Model"><meta name=twitter:description content="1."><script type=application/ld+json>[{"@context":"https://schema.org","@type":"Article","articleSection":"Posts","name":"[DuckDB] Push-Based Execution Model","headline":"[DuckDB] Push-Based Execution Model","abstract":"1.","inLanguage":"en","url":"https:\/\/zz-jason.github.io\/posts\/duckdb-push-based-execution-model\/","author":{"@type":"Person","name":"Jian Zhang"},"copyrightYear":"2022","dateCreated":"2022-11-14T08:36:00\u002b08:00","datePublished":"2022-11-14T08:36:00\u002b08:00","dateModified":"2022-11-14T08:36:00\u002b08:00","mainEntityOfPage":"true","wordCount":"2082"}]</script><meta name=author content="Jian Zhang"><link href=zjsariel@gmail.com rel=me><link href=https://github.com/zz-jason rel=me><link href=https://linkedin.com/in/zhangjian1012 rel=me><link href=https://twitter.com/zhangjian1012 rel=me><script src=/lib/jquery/jquery.slim.min.js integrity></script>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-67872953-1"></script>
<script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","UA-67872953-1")</script><meta name=theme-color></head><body class="flex flex-col h-screen px-6 m-auto text-lg leading-7 max-w-7xl bg-neutral text-neutral-900 dark:bg-neutral-800 dark:text-neutral sm:px-14 md:px-24 lg:px-32"><div id=the-top class="absolute flex self-center"><a class="px-3 py-1 text-sm -translate-y-8 rounded-b-lg bg-primary-200 focus:translate-y-0 dark:bg-neutral-600" href=#main-content><span class="font-bold text-primary-600 ltr:pr-2 rtl:pl-2 dark:text-primary-400">&darr;</span>Skip to main content</a></div><div style=padding-left:0;padding-right:0;padding-top:2px;padding-bottom:3px class="main-menu flex items-center justify-between px-4 py-6 sm:px-6 md:justify-start space-x-3"><div class="flex flex-1 items-center justify-between"><nav class="flex space-x-3"><a href=/ class="text-base font-medium text-gray-500 hover:text-gray-900">Jian Zhang</a></nav><nav class="hidden md:flex items-center space-x-5 md:ml-12"><a href=/posts/ class="flex items-center"><p class="text-base font-medium text-gray-500 hover:text-gray-900" title=Posts>Achieves</p></a><a href=/categories/ class="flex items-center"><p class="text-base font-medium text-gray-500 hover:text-gray-900" title=Categories>Categories</p></a><a href=/about/ class="flex items-center"><p class="text-base font-medium text-gray-500 hover:text-gray-900" title="About Me">About</p></a></nav><div class="flex md:hidden items-center space-x-5 md:ml-12"><span></span></div></div><div class="-my-2 -mr-2 md:hidden"><label id=menu-button for=menu-controller class=block><input type=checkbox id=menu-controller class=hidden><div class="cursor-pointer hover:text-primary-600 dark:hover:text-primary-400"><span class="relative block icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path fill="currentcolor" d="M0 96C0 78.33 14.33 64 32 64H416c17.7.0 32 14.33 32 32 0 17.7-14.3 32-32 32H32C14.33 128 0 113.7.0 96zM0 256c0-17.7 14.33-32 32-32H416c17.7.0 32 14.3 32 32s-14.3 32-32 32H32c-17.67.0-32-14.3-32-32zM416 448H32c-17.67.0-32-14.3-32-32s14.33-32 32-32H416c17.7.0 32 14.3 32 32s-14.3 32-32 32z"/></svg></span></div><div id=menu-wrapper style=padding-top:5px class="fixed inset-0 z-30 invisible w-screen h-screen m-auto overflow-auto transition-opacity opacity-0 cursor-default bg-neutral-100/50 backdrop-blur-sm dark:bg-neutral-900/50"><ul class="flex space-y-2 mt-3 flex-col items-end w-full px-6 py-6 mx-auto overflow-visible list-none ltr:text-right rtl:text-left max-w-7xl"><li><span class="cursor-pointer inline-block align-text-bottom hover:text-primary-600 dark:hover:text-primary-400"><span class="relative block icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><path fill="currentcolor" d="M310.6 361.4c12.5 12.5 12.5 32.75.0 45.25C304.4 412.9 296.2 416 288 416s-16.38-3.125-22.62-9.375L160 301.3 54.63 406.6C48.38 412.9 40.19 416 32 416S15.63 412.9 9.375 406.6c-12.5-12.5-12.5-32.75.0-45.25l105.4-105.4L9.375 150.6c-12.5-12.5-12.5-32.75.0-45.25s32.75-12.5 45.25.0L160 210.8l105.4-105.4c12.5-12.5 32.75-12.5 45.25.0s12.5 32.75.0 45.25l-105.4 105.4L310.6 361.4z"/></svg></span></span></li><li class=mt-1><a href=/posts/ class="flex items-center"><p class="text-bg font-bg text-gray-500 hover:text-gray-900" title=Posts>Achieves</p></a></li><li class=mt-1><a href=/categories/ class="flex items-center"><p class="text-bg font-bg text-gray-500 hover:text-gray-900" title=Categories>Categories</p></a></li><li class=mt-1><a href=/about/ class="flex items-center"><p class="text-bg font-bg text-gray-500 hover:text-gray-900" title="About Me">About</p></a></li></ul></div></label></div></div><script>(function(){var e=$(".main-menu"),t=window.location.pathname;e.find('a[href="'+t+'"]').each(function(e,t){$(t).children("p").addClass("active")})})()</script><div class="relative flex flex-col grow"><main id=main-content class=grow><article><div class="fixed inset-x-0 top-0 h-[800px] single_hero_background nozoom" style=background-image:url(/img/default-background_huec8bd3c67ccf6276b6663a09c1e6b7ab_383486_1200x0_resize_box_3.png)><div class="absolute inset-0 bg-gradient-to-t from-neutral dark:from-neutral-800 to-transparent mix-blend-normal"></div><div class="absolute inset-0 opacity-60 bg-gradient-to-t from-neutral dark:from-neutral-800 to-neutral-100 dark:to-neutral-800 mix-blend-normal"></div></div><div id=background-blur class="fixed opacity-0 inset-x-0 top-0 h-full single_hero_background nozoom backdrop-blur-2xl"></div><script>window.addEventListener("scroll",function(){var t=window.pageYOffset||document.documentElement.scrollTop||document.body.scrollTop||0,n=document.getElementById("background-blur");n.style.opacity=t/300})</script><header id=single_header class="mt-5 max-w-prose"><h1 class="mt-0 text-4xl font-extrabold text-neutral-900 dark:text-neutral">[DuckDB] Push-Based Execution Model</h1><div class="mt-1 mb-6 text-base text-neutral-500 dark:text-neutral-400 print:hidden"><div class="flex flex-row flex-wrap items-center"><time datetime="2022-11-14 08:36:00 +0800 +0800">14 November 2022</time><span class="px-2 text-primary-500">&#183;</span><span>2082 words</span><span class="px-2 text-primary-500">&#183;</span><span title="Reading time">10 mins</span></div><div class="flex flex-row flex-wrap items-center"><span style=margin-top:.5rem class=mr-2 onclick='window.open("/categories/duckdb/","_self")'><span class=flex><span class="rounded-md border border-primary-400 px-1 py-[1px] text-xs font-normal text-primary-700 dark:border-primary-600 dark:text-primary-400">DuckDB</span></span></span></div></div></header><section class="flex flex-col max-w-full mt-0 prose dark:prose-invert lg:flex-row"><div class="order-first sm:max-w-prose lg:ml-auto px-0 lg:order-last lg:max-w-xs ltr:lg:pl-8 rtl:lg:pr-8"><div class="toc ltr:pl-5 rtl:pr-5 print:hidden lg:sticky lg:top-10"><details open class="mt-0 overflow-hidden rounded-lg ltr:-ml-5 ltr:pl-5 rtl:-mr-5 rtl:pr-5 hidden lg:block"><summary class="block py-1 text-lg font-semibold cursor-pointer bg-neutral-100 text-neutral-800 ltr:-ml-5 ltr:pl-5 rtl:-mr-5 rtl:pr-5 dark:bg-neutral-700 dark:text-neutral-100 lg:hidden">Table of Contents</summary><div class="min-w-[220px] py-2 border-dotted border-neutral-300 ltr:-ml-5 ltr:border-l ltr:pl-5 rtl:-mr-5 rtl:border-r rtl:pr-5 dark:border-neutral-600"><nav id=TableOfContents><ul><li><a href=#1-背景>1. 背景</a></li><li><a href=#2-执行框架概览>2. 执行框架概览</a></li><li><a href=#3-taskscheduler-和后台线程池>3. TaskScheduler 和后台线程池</a></li><li><a href=#4-executortask-和-event-驱动的调度模型>4. ExecutorTask 和 Event 驱动的调度模型</a></li><li><a href=#5-pipelineexecutor-和-pipeline-内基于-push-的执行模型>5. PipelineExecutor 和 Pipeline 内基于 Push 的执行模型</a></li><li><a href=#6-主线程和-root-pipeline-的执行>6. 主线程和 root Pipeline 的执行</a></li><li><a href=#7-pipeline-的构造>7. Pipeline 的构造</a><ul><li><a href=#71-从-physicalunion-构造-pipeline>7.1. 从 PhysicalUnion 构造 Pipeline</a></li><li><a href=#72-从-physicaljoin-构造-pipeline>7.2. 从 PhysicalJoin 构造 Pipeline</a></li></ul></li><li><a href=#8-duckdb-执行模式的一些感受和思考>8. DuckDB 执行模式的一些感受和思考</a><ul><li><a href=#81-计算调度的复杂性>8.1. 计算调度的复杂性</a></li><li><a href=#81-pipelinebreaker-的作用>8.1. PipelineBreaker 的作用</a></li><li><a href=#83-除了带来性能提升外这种并发-push-执行模型还有其他优势吗>8.3. 除了带来性能提升外，这种并发 Push 执行模型还有其他优势吗？</a></li></ul></li><li><a href=#9-参考材料>9. 参考材料</a></li></ul></nav></div></details><details class="mt-0 overflow-hidden rounded-lg ltr:-ml-5 ltr:pl-5 rtl:-mr-5 rtl:pr-5 lg:hidden"><summary class="py-1 text-lg font-semibold cursor-pointer bg-neutral-100 text-neutral-800 ltr:-ml-5 ltr:pl-5 rtl:-mr-5 rtl:pr-5 dark:bg-neutral-700 dark:text-neutral-100 lg:hidden">Table of Contents</summary><div class="py-2 border-dotted border-neutral-300 ltr:-ml-5 ltr:border-l ltr:pl-5 rtl:-mr-5 rtl:border-r rtl:pr-5 dark:border-neutral-600"><nav id=TableOfContents><ul><li><a href=#1-背景>1. 背景</a></li><li><a href=#2-执行框架概览>2. 执行框架概览</a></li><li><a href=#3-taskscheduler-和后台线程池>3. TaskScheduler 和后台线程池</a></li><li><a href=#4-executortask-和-event-驱动的调度模型>4. ExecutorTask 和 Event 驱动的调度模型</a></li><li><a href=#5-pipelineexecutor-和-pipeline-内基于-push-的执行模型>5. PipelineExecutor 和 Pipeline 内基于 Push 的执行模型</a></li><li><a href=#6-主线程和-root-pipeline-的执行>6. 主线程和 root Pipeline 的执行</a></li><li><a href=#7-pipeline-的构造>7. Pipeline 的构造</a><ul><li><a href=#71-从-physicalunion-构造-pipeline>7.1. 从 PhysicalUnion 构造 Pipeline</a></li><li><a href=#72-从-physicaljoin-构造-pipeline>7.2. 从 PhysicalJoin 构造 Pipeline</a></li></ul></li><li><a href=#8-duckdb-执行模式的一些感受和思考>8. DuckDB 执行模式的一些感受和思考</a><ul><li><a href=#81-计算调度的复杂性>8.1. 计算调度的复杂性</a></li><li><a href=#81-pipelinebreaker-的作用>8.1. PipelineBreaker 的作用</a></li><li><a href=#83-除了带来性能提升外这种并发-push-执行模型还有其他优势吗>8.3. 除了带来性能提升外，这种并发 Push 执行模型还有其他优势吗？</a></li></ul></li><li><a href=#9-参考材料>9. 参考材料</a></li></ul></nav></div></details><script>(function(){var t,e=$("#TableOfContents");if(e.length>0){t=$(window);function n(){var s,o=t.scrollTop(),i=$(".anchor"),n="";if(i.each(function(e,t){t=$(t),t.offset().top-$(window).height()/3<=o&&(n=t.attr("id"))}),s=e.find("a.active"),s.length==1&&s.eq(0).attr("href")=="#"+n)return!0;s.each(function(e,t){$(t).removeClass("active")}),e.find('a[href="#'+n+'"]').addClass("active"),e.find('a[href="#'+n+'"]').parentsUntil("#TableOfContents").each(function(e,t){$(t).children("a").parents("ul").show()})}t.on("scroll",n),$(document).ready(function(){n()})}})()</script></div></div><div class="min-w-0 min-h-0 max-w-prose"><div id=1-背景 class=anchor></div><h2 class="relative group">1. 背景
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#1-%e8%83%8c%e6%99%af aria-label=Anchor>#</a></span></h2><p>DuckDB 是我非常喜欢的一个数据库，它基于 <a href=https://github.com/duckdb/duckdb/tree/master/third_party/libpg_query target=_blank>libpg_query</a> 实现了 SQL Parser，语法和 PostgreSQL 一致，内嵌 SQLite 的 REPL CLI，编译好后可直接运行 CLI 交互式输入 SQL 得到结果。架构简单、分析性能优秀、代码干净好读，极易上手。</p><p>10 月初偶然间翻看 duckdb 的代码，发现他的执行引擎和计算调度采用了类似 Hyper 在《<a href=https://15721.courses.cs.cmu.edu/spring2016/papers/p743-leis.pdf target=_blank>
Morsel-Driven Parallelism: A NUMA-Aware Query Evaluation Framework for the Many-Core Age</a>》中提出的 Morsel-Driven 的方式，实现了 push-based execution model，它的 pipeline breaker 语义和也 Hyper 在《<a href=https://www.vldb.org/pvldb/vol4/p539-neumann.pdf target=_blank>
Efficiently Compiling Efficient Query Plans for Modern Hardware</a>》 中定义的一致，不同的是 Hyper 期望通过 LLVM JIT 的方式对数据一行一行计算使其尽量保存在寄存器中，DuckDB 采用向量化使一批数据尽可能保存在 CPU Cache 中。</p><p>之前做 TiDB 时研究过很多 Hyper 和 Vectorize 的论文，也做过几次分享，一直希望实现一个简单 demo 验证下效果，正好 DuckDB 采用了类似实现，这就勾起了我浓烈的好奇心。因此利用周末时间研究了下 DuckDB 是如何实现 push-based execution model 的，这里分享给大家，希望帮助到同样感兴趣的朋友们。</p><div id=2-执行框架概览 class=anchor></div><h2 class="relative group">2. 执行框架概览
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#2-%e6%89%a7%e8%a1%8c%e6%a1%86%e6%9e%b6%e6%a6%82%e8%a7%88 aria-label=Anchor>#</a></span></h2><p>DuckDB 启动时会创建一个全局的 TaskScheduler，启动 nproc-1（main 函数）个后台线程。这些后台线程启动后会不停地从位于 TaskScheduler 的 Task 队列中取出和执行 Task。DuckDB 通过这个后台线程池和公共 Task 队列完成了 Query 的并发执行。</p><p>DuckDB 基于 Query 的物理执行计划 PhysicalOperator tree 构造了 Pipeline DAG。每个 Pipeline 代表了物理执行计划中一段连续的 PhysicalOperator 算子，由 source、operators 和 sink 构成。当且仅当 Pipeline 的所有 dependency 都执行完后，该 Pipeline 才可被执行。Pipeline 的 sink 代表了需要消费掉所有输入数据才能对外返回结果的 PhysicalOperator。Pipeline DAG 可以看做是另一种视角下的物理执行计划。</p><p>DuckDB 为每个 Pipeline 构造多个 ExecutorTask 使得 Pipeline 可以被多个线程并发执行，Pipeline 的 source 和 sink 需要是并发安全的。后台线程取得 ExecutorTask 后会通过其中的 PipelineExecutor 执行 Pipeline，当执行完一个 ExecutorTask 后，Pipeline 的一个并发任务也就执行完了。</p><p>为了正确调度和执行 Pipeline DAG 中所有的 Pipeline 和它们对应的 ExecutorTask，我们需要能够及时知道某个 Pipeline 的所有并发是否都执行完毕，在其父亲 Pipeline 的所有依赖都被执行完后及时调度父亲 Pipeline 的所有 ExecutorTask，DuckDB 采用了 Event 来生成和调度对应的 ExecutorTask。</p><p>每个 Pipeline 的 Event 都记录了需要执行的总并发数和完成的并发数。在构造 Pipeline DAG 后，DuckDB 会为其构造一个对应的 Event DAG，Pipeline 通过 Event 完成了 ExecutorTask 的调度和执行。每当一个 ExecutorTask 完成，该 Event 的完成并发数就会加 1，当该 Pipeline 的所有 ExecutorTask 都完成后，Event 中的总并发数和已完成并发数相等，标志着该 Event 也完成，该 Event 会通知其父亲 Event，父亲 Event 一旦检测到所有 dependency Event 都执行完，就会调度自己的 ExecutorTask，从而驱动后续的 Pipeilne 计算。</p><p>ExecutorTask 中的 Pipeline 是以 push 的方式执行的：先从 Pipeline 的 source 获取一批数据，然后将该批数据依次的通过所有中间的 operators 计算，最终由 sink 完成这一批初始数据的最终计算。典型的 sink 比如构造 hash table：当前 Pipeline 的所有 ExecutorTask 执行完后，最终的 hash table 才构造好，才能用来 probe 产生结果。</p><p>为了返回结果给客户端，当前 Query 的主线程会不断调用 root PipelineExecutor 的 pull 接口。需要注意的是，这个接口名字的 pull 指的仅仅是从最顶层 Pipeline 拿结果数据，在计算顶层 Pipeline 的时候仍然是从 source 到最后一个 PhysicalOperator push 计算过去的。root PipelineExecutor 拿到一批 source 数据代表着 root Pipeline 依赖的所有 PipelineTask 都执行完毕，之后 root PipelineExecutor 内部以 push 的方式执行完这一批数据得到结果，将结果返回给客户端，用户就可以看到 Query 执行结果了。</p><p>以上就是 DuckDB 执行框架的大致介绍。因为要特殊考虑一些算子的特殊优化，所以实际实现会稍微复杂一些。比如 UNION ALL，DuckDB 会在一段 PhysicalOperator 链条上构造多个 Pipeline。考虑到 partitioned hash join 的高效实现，DuckDB 也会在一段 PhysicalOperator 链条上构造多个 Pipeline，和 UNION ALL 不同的是，这些 Pipeline 之间有执行顺序的依赖关系。最终构造出来的可能就是有多个 root 的 Pipeline DAG。</p><p>本文以当前（2022-11-14）DuckDB master 分支的 commit 为例，学习 DuckDB push-based execution model 涉及到的关键代码路径，感兴趣的朋友可以试试 clone 代码编译和调试玩玩。在 DuckDB 中，Pipeline 的构造、Event 的调度都发生在 Executor::InitializeInternal() 函数中，本文后续的内容也将围绕这里面的关键函数展开，其中几个关键的函数为：</p><ol><li>root_pipeline->Build(physical_plan)：top-down 的构造 Pipeline DAG</li><li>ScheduleEvents(to_schedule)：基于除了 root Pipeline 以外的其他 Pipeline 构造 Event DAG，完成初始 Event 和 ExecutorTask 的调度。</li></ol><p>Executor::InitializeInternal() 函数的完整代码如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>void</span> <span class=n>Executor</span><span class=o>::</span><span class=n>InitializeInternal</span><span class=p>(</span><span class=n>PhysicalOperator</span> <span class=o>*</span><span class=n>plan</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>auto</span> <span class=o>&amp;</span><span class=n>scheduler</span> <span class=o>=</span> <span class=n>TaskScheduler</span><span class=o>::</span><span class=n>GetScheduler</span><span class=p>(</span><span class=n>context</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>lock_guard</span><span class=o>&lt;</span><span class=n>mutex</span><span class=o>&gt;</span> <span class=n>elock</span><span class=p>(</span><span class=n>executor_lock</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>physical_plan</span> <span class=o>=</span> <span class=n>plan</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>this</span><span class=o>-&gt;</span><span class=n>profiler</span> <span class=o>=</span> <span class=n>ClientData</span><span class=o>::</span><span class=n>Get</span><span class=p>(</span><span class=n>context</span><span class=p>).</span><span class=n>profiler</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>profiler</span><span class=o>-&gt;</span><span class=n>Initialize</span><span class=p>(</span><span class=n>physical_plan</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>this</span><span class=o>-&gt;</span><span class=n>producer</span> <span class=o>=</span> <span class=n>scheduler</span><span class=p>.</span><span class=n>CreateProducer</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1>// build and ready the pipelines
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>PipelineBuildState</span> <span class=n>state</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>auto</span> <span class=n>root_pipeline</span> <span class=o>=</span> <span class=n>make_shared</span><span class=o>&lt;</span><span class=n>MetaPipeline</span><span class=o>&gt;</span><span class=p>(</span><span class=o>*</span><span class=k>this</span><span class=p>,</span> <span class=n>state</span><span class=p>,</span> <span class=k>nullptr</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>root_pipeline</span><span class=o>-&gt;</span><span class=n>Build</span><span class=p>(</span><span class=n>physical_plan</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>root_pipeline</span><span class=o>-&gt;</span><span class=n>Ready</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1>// ready recursive cte pipelines too
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>for</span> <span class=p>(</span><span class=k>auto</span> <span class=o>&amp;</span><span class=nl>rec_cte</span> <span class=p>:</span> <span class=n>recursive_ctes</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>D_ASSERT</span><span class=p>(</span><span class=n>rec_cte</span><span class=o>-&gt;</span><span class=n>type</span> <span class=o>==</span> <span class=n>PhysicalOperatorType</span><span class=o>::</span><span class=n>RECURSIVE_CTE</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=k>auto</span> <span class=o>&amp;</span><span class=n>rec_cte_op</span> <span class=o>=</span> <span class=p>(</span><span class=n>PhysicalRecursiveCTE</span> <span class=o>&amp;</span><span class=p>)</span><span class=o>*</span><span class=n>rec_cte</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=n>rec_cte_op</span><span class=p>.</span><span class=n>recursive_meta_pipeline</span><span class=o>-&gt;</span><span class=n>Ready</span><span class=p>();</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1>// set root pipelines, i.e., all pipelines that end in the final sink
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>root_pipeline</span><span class=o>-&gt;</span><span class=n>GetPipelines</span><span class=p>(</span><span class=n>root_pipelines</span><span class=p>,</span> <span class=nb>false</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>root_pipeline_idx</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1>// collect all meta-pipelines from the root pipeline
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>vector</span><span class=o>&lt;</span><span class=n>shared_ptr</span><span class=o>&lt;</span><span class=n>MetaPipeline</span><span class=o>&gt;&gt;</span> <span class=n>to_schedule</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>root_pipeline</span><span class=o>-&gt;</span><span class=n>GetMetaPipelines</span><span class=p>(</span><span class=n>to_schedule</span><span class=p>,</span> <span class=nb>true</span><span class=p>,</span> <span class=nb>true</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1>// number of &#39;PipelineCompleteEvent&#39;s is equal to the number of meta pipelines, so we have to set it here
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>total_pipelines</span> <span class=o>=</span> <span class=n>to_schedule</span><span class=p>.</span><span class=n>size</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1>// collect all pipelines from the root pipelines (recursively) for the progress bar and verify them
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>root_pipeline</span><span class=o>-&gt;</span><span class=n>GetPipelines</span><span class=p>(</span><span class=n>pipelines</span><span class=p>,</span> <span class=nb>true</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1>// finally, verify and schedule
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>VerifyPipelines</span><span class=p>();</span>
</span></span><span class=line><span class=cl>        <span class=n>ScheduleEvents</span><span class=p>(</span><span class=n>to_schedule</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><div id=3-taskscheduler-和后台线程池 class=anchor></div><h2 class="relative group">3. TaskScheduler 和后台线程池
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#3-taskscheduler-%e5%92%8c%e5%90%8e%e5%8f%b0%e7%ba%bf%e7%a8%8b%e6%b1%a0 aria-label=Anchor>#</a></span></h2><p>在 DuckDB 启动时会创建一个全局的 TaskScheduler，在后台启动 nproc-1（main 函数）个后台线程，启动线程是在 TaskScheduler::SetThreadsInternal() 函数中进行的，从主线程启动线程池的调用堆栈如下，感兴趣的朋友们可以根据这些关键函数看看线程是如何启动起来的：</p><pre tabindex=0><code>(lldb) bt
* thread #1, queue = &#39;com.apple.main-thread&#39;, stop reason = breakpoint 1.1
  * frame #0: 0x00000001074e29ee duckdb`duckdb::TaskScheduler::SetThreadsInternal(this=0x00006060000015e0, n=12) at task_scheduler.cpp:239:4
    frame #1: 0x00000001074e5335 duckdb`duckdb::TaskScheduler::SetThreads(this=0x00006060000015e0, n=12) at task_scheduler.cpp:199:2
    frame #2: 0x0000000107099f45 duckdb`duckdb::DatabaseInstance::Initialize(this=0x0000616000000698, database_path=0x0000000000000000, user_config=0x00007ff7bfefd420) at database.cpp:159:13
    frame #3: 0x000000010709f2ce duckdb`duckdb::DuckDB::DuckDB(this=0x0000602000000a90, path=0x0000000000000000, new_config=0x00007ff7bfefd420) at database.cpp:170:12
    frame #4: 0x000000010709f689 duckdb`duckdb::DuckDB::DuckDB(this=0x0000602000000a90, path=0x0000000000000000, new_config=0x00007ff7bfefd420) at database.cpp:169:100
    ...
</code></pre><p>后台线程启动后的主逻辑在 TaskScheduler::ExecuteForever() 中，在每个后台线程的生命周期内，它们会不停从 TaskScheduler 的公共队列中取出 Task，调用 Task::Execute() 函数完成 Task 的执行：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>void</span> <span class=n>TaskScheduler</span><span class=o>::</span><span class=n>ExecuteForever</span><span class=p>(</span><span class=n>atomic</span><span class=o>&lt;</span><span class=kt>bool</span><span class=o>&gt;</span> <span class=o>*</span><span class=n>marker</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=cp>#ifndef DUCKDB_NO_THREADS
</span></span></span><span class=line><span class=cl><span class=cp></span>    <span class=n>unique_ptr</span><span class=o>&lt;</span><span class=n>Task</span><span class=o>&gt;</span> <span class=n>task</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=c1>// loop until the marker is set to false
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>while</span> <span class=p>(</span><span class=o>*</span><span class=n>marker</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// wait for a signal with a timeout
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>queue</span><span class=o>-&gt;</span><span class=n>semaphore</span><span class=p>.</span><span class=n>wait</span><span class=p>();</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>queue</span><span class=o>-&gt;</span><span class=n>q</span><span class=p>.</span><span class=n>try_dequeue</span><span class=p>(</span><span class=n>task</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>task</span><span class=o>-&gt;</span><span class=n>Execute</span><span class=p>(</span><span class=n>TaskExecutionMode</span><span class=o>::</span><span class=n>PROCESS_ALL</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=n>task</span><span class=p>.</span><span class=n>reset</span><span class=p>();</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=cp>#else
</span></span></span><span class=line><span class=cl><span class=cp></span>    <span class=k>throw</span> <span class=nf>NotImplementedException</span><span class=p>(</span><span class=s>&#34;DuckDB was compiled without threads! Background thread loop is not allowed.&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=cp>#endif
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=p>}</span>
</span></span></code></pre></div><p>Pipeline 的各个 Task 就是这样被后台线程并发执行的。要想控制 Pipeline 之间的执行顺序和 Pipeline 内的并发度，只需要设计和控制好各个 ExecutorTask 入队的顺序即可。Pipeline 的执行主要依靠 ExecutorTask，各个算子如果需要自定义计算逻辑和调度规则也是通过实现新的 ExecutorTask 完成。</p><div id=4-executortask-和-event-驱动的调度模型 class=anchor></div><h2 class="relative group">4. ExecutorTask 和 Event 驱动的调度模型
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#4-executortask-%e5%92%8c-event-%e9%a9%b1%e5%8a%a8%e7%9a%84%e8%b0%83%e5%ba%a6%e6%a8%a1%e5%9e%8b aria-label=Anchor>#</a></span></h2><p><figure><img class="my-0 rounded-md" src=/images/duckdb-push-based-execution-model/Task-Event.jpg alt="Event based scheduling model"></figure></p><p>在 Task 的执行框架内，后台线程会通过 ExecutorTask::Execute() 驱动当前 ExecutorTask 的执行。为了给各个 Pipeline 和 PhysicalOperator 提供灵活的执行方式，DuckDB 内各个 PhysicalOperator 可以各自实现特定的 ExecutorTask 用于完成自身特殊的计算任务和后续 Pipeline Task 的计算调度。ExecutorTask::Execute() 的执行会直接调用子类的 ExecutorTask::ExecuteTask() 函数完成当前 ExecutorTask 的实际执行。</p><p>对于一般的 Pipeline 来说，会构造一个叫 PipelineTask 的 ExecutorTask 子类。PipelineTask::ExecuteTask() 的代码逻辑如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>TaskExecutionResult</span> <span class=nf>ExecuteTask</span><span class=p>(</span><span class=n>TaskExecutionMode</span> <span class=n>mode</span><span class=p>)</span> <span class=k>override</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>pipeline_executor</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>pipeline_executor</span> <span class=o>=</span> <span class=n>make_unique</span><span class=o>&lt;</span><span class=n>PipelineExecutor</span><span class=o>&gt;</span><span class=p>(</span><span class=n>pipeline</span><span class=p>.</span><span class=n>GetClientContext</span><span class=p>(),</span> <span class=n>pipeline</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>mode</span> <span class=o>==</span> <span class=n>TaskExecutionMode</span><span class=o>::</span><span class=n>PROCESS_PARTIAL</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=kt>bool</span> <span class=n>finished</span> <span class=o>=</span> <span class=n>pipeline_executor</span><span class=o>-&gt;</span><span class=n>Execute</span><span class=p>(</span><span class=n>PARTIAL_CHUNK_COUNT</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>finished</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=n>TaskExecutionResult</span><span class=o>::</span><span class=n>TASK_NOT_FINISHED</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>pipeline_executor</span><span class=o>-&gt;</span><span class=n>Execute</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>event</span><span class=o>-&gt;</span><span class=n>FinishTask</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=n>pipeline_executor</span><span class=p>.</span><span class=n>reset</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>TaskExecutionResult</span><span class=o>::</span><span class=n>TASK_FINISHED</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>在 PipelineTask::ExecuteTask() 中，通过 PipelineExecutor::Execute() 完成当前 ExecutorTask 的执行后它会去调用 Event::FinishTask() 函数进行 ExecutorTask 完成后各个 Event 子类自定义的收尾工作，在 Event::FinishTask() 函数如果发现当前 Event 的所有 Task 都执行完毕就会清理当前 Event 相关内容，并调用父亲 Event 的 CompleteDependency()：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>void</span> <span class=n>Event</span><span class=o>::</span><span class=n>Finish</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>D_ASSERT</span><span class=p>(</span><span class=o>!</span><span class=n>finished</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>FinishEvent</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=n>finished</span> <span class=o>=</span> <span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=c1>// finished processing the pipeline, now we can schedule pipelines that depend on this pipeline
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>for</span> <span class=p>(</span><span class=k>auto</span> <span class=o>&amp;</span><span class=nl>parent_entry</span> <span class=p>:</span> <span class=n>parents</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>auto</span> <span class=n>parent</span> <span class=o>=</span> <span class=n>parent_entry</span><span class=p>.</span><span class=n>lock</span><span class=p>();</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>parent</span><span class=p>)</span> <span class=p>{</span> <span class=c1>// LCOV_EXCL_START
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=k>continue</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span> <span class=c1>// LCOV_EXCL_STOP
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>// mark a dependency as completed for each of the parents
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>parent</span><span class=o>-&gt;</span><span class=n>CompleteDependency</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>FinalizeFinish</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>在 Event::CompleteDependency() 中，如果发现所有 dependency Event 都已经执行完毕，则会开始调度执行父亲 Event 的 Task。如果父亲 Event 没有 task 需要执行，则会再调用父亲 Event 的 Finish() 函数直接在当前线程中完成父亲 Event 的执行和收尾：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>void</span> <span class=n>Event</span><span class=o>::</span><span class=n>CompleteDependency</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>idx_t</span> <span class=n>current_finished</span> <span class=o>=</span> <span class=o>++</span><span class=n>finished_dependencies</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>D_ASSERT</span><span class=p>(</span><span class=n>current_finished</span> <span class=o>&lt;=</span> <span class=n>total_dependencies</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>current_finished</span> <span class=o>==</span> <span class=n>total_dependencies</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// all dependencies have been completed: schedule the event
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>D_ASSERT</span><span class=p>(</span><span class=n>total_tasks</span> <span class=o>==</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>Schedule</span><span class=p>();</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>total_tasks</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>Finish</span><span class=p>();</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>从上面代码可以看到 Event 调度 Task 是通过 Event::Schedule() 函数完成的，这是个 Event 的纯虚函数，不同的子类 Event 需要自行实现。Pipeline 执行过程中使用的 Event 类型不多，最常见的是：</p><ul><li>PipelineInitializeEvent：主要用来初始化当前 Pipeline 的 sink，会调度 1 个 PipelineInitializeTask</li><li>PipelineEvent：主要用来表示 Pipeline 的执行操作，可能会调度多个 ExecutorTask 到执行队列中。PipelineEvent 的 Schedule() 函数主要调用 Pipeline::Schedule() 完成 ExecutorTask 的计算调度，这里不再展开，感兴趣的朋友们可以继续追踪代码看看其中的实现细节</li><li>PipelineFinishEvent：主要用来标记当前 Pipeline 执行结束，在 Event::Finish() 检测到当前 Event 结束，调用到 PipelineFinishEvent::FinishEvent() 时完成 Pipeline::Finalize()，用来做 Pipeline 的清理操作</li><li>PipelineCompleteEvent：用来更新 Executor 中已结束的 Pipeline 的 counter completed_pipelines，Executor 主线程会不断检测 completed_pipelines，当发现所有中间 Pipeline 都执行完后，主线程会开始执行 root Pipeline，返回结果给客户端。</li></ul><p>我们在上面 Executor::InitializeInternal() 的函数中看到，DuckDB 的 Pipeline 分为了 2 部分：</p><ol><li>中间 Pipelines：包含所有除了 root 以外的 Pipeline。DuckDB 基于这些 Pipeline 之间的依赖关系构建了相应的 Event DAG，通过调度最底层没有任何依赖 Event 的 ExecutorTask 初始化了 TaskScheduler 的执行队列，进而催动了所有中间 Pipeline 的执行。</li><li>root Pipelines：在构建 Event DAG 的时候不会将这部分 Pipeline 考虑进去，这部分 Pipeline 也不会被 TaskScheduler 启动的后台线程异步执行。在完成中间 Pipeline 的初始调度后，主线程后续的工作和 root Pipeline 的执行过程我们在后面的小结来看。</li></ol><p>Pipeline 的初始调度正是由主线程执行 Executor::ScheduleEvents() 触发的，正式的调度逻辑是由 Executor::ScheduleEventsInternal() 完成的，这个函数的大致逻辑如下。概括来说就是寻找没有任何 dependency 的 Event，通过执行这些 Event.Schedule() 构造 ExecutorTask，放入 TaskScheduler 的工作队列，激活后台工作线程，开始 Pipeline 执行以及其他 Event 和 ExecutorTask 的连锁反应：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>void</span> <span class=n>Executor</span><span class=o>::</span><span class=n>ScheduleEventsInternal</span><span class=p>(</span><span class=n>ScheduleEventData</span> <span class=o>&amp;</span><span class=n>event_data</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>auto</span> <span class=o>&amp;</span><span class=n>events</span> <span class=o>=</span> <span class=n>event_data</span><span class=p>.</span><span class=n>events</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>D_ASSERT</span><span class=p>(</span><span class=n>events</span><span class=p>.</span><span class=n>empty</span><span class=p>());</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// create all the required pipeline events
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>for</span> <span class=p>(</span><span class=k>auto</span> <span class=o>&amp;</span><span class=nl>pipeline</span> <span class=p>:</span> <span class=n>event_data</span><span class=p>.</span><span class=n>meta_pipelines</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>SchedulePipeline</span><span class=p>(</span><span class=n>pipeline</span><span class=p>,</span> <span class=n>event_data</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// set up the dependencies across MetaPipelines
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>auto</span> <span class=o>&amp;</span><span class=n>event_map</span> <span class=o>=</span> <span class=n>event_data</span><span class=p>.</span><span class=n>event_map</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=k>auto</span> <span class=o>&amp;</span><span class=nl>entry</span> <span class=p>:</span> <span class=n>event_map</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>auto</span> <span class=n>pipeline</span> <span class=o>=</span> <span class=n>entry</span><span class=p>.</span><span class=n>first</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=p>(</span><span class=k>auto</span> <span class=o>&amp;</span><span class=nl>dependency</span> <span class=p>:</span> <span class=n>pipeline</span><span class=o>-&gt;</span><span class=n>dependencies</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>auto</span> <span class=n>dep</span> <span class=o>=</span> <span class=n>dependency</span><span class=p>.</span><span class=n>lock</span><span class=p>();</span>
</span></span><span class=line><span class=cl>            <span class=n>D_ASSERT</span><span class=p>(</span><span class=n>dep</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=k>auto</span> <span class=n>event_map_entry</span> <span class=o>=</span> <span class=n>event_map</span><span class=p>.</span><span class=n>find</span><span class=p>(</span><span class=n>dep</span><span class=p>.</span><span class=n>get</span><span class=p>());</span>
</span></span><span class=line><span class=cl>            <span class=n>D_ASSERT</span><span class=p>(</span><span class=n>event_map_entry</span> <span class=o>!=</span> <span class=n>event_map</span><span class=p>.</span><span class=n>end</span><span class=p>());</span>
</span></span><span class=line><span class=cl>            <span class=k>auto</span> <span class=o>&amp;</span><span class=n>dep_entry</span> <span class=o>=</span> <span class=n>event_map_entry</span><span class=o>-&gt;</span><span class=n>second</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=n>D_ASSERT</span><span class=p>(</span><span class=n>dep_entry</span><span class=p>.</span><span class=n>pipeline_complete_event</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=n>entry</span><span class=p>.</span><span class=n>second</span><span class=p>.</span><span class=n>pipeline_event</span><span class=o>-&gt;</span><span class=n>AddDependency</span><span class=p>(</span><span class=o>*</span><span class=n>dep_entry</span><span class=p>.</span><span class=n>pipeline_complete_event</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// verify that we have no cyclic dependencies
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>VerifyScheduledEvents</span><span class=p>(</span><span class=n>event_data</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// schedule the pipelines that do not have dependencies
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>for</span> <span class=p>(</span><span class=k>auto</span> <span class=o>&amp;</span><span class=nl>event</span> <span class=p>:</span> <span class=n>events</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>event</span><span class=o>-&gt;</span><span class=n>HasDependencies</span><span class=p>())</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>event</span><span class=o>-&gt;</span><span class=n>Schedule</span><span class=p>();</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><div id=5-pipelineexecutor-和-pipeline-内基于-push-的执行模型 class=anchor></div><h2 class="relative group">5. PipelineExecutor 和 Pipeline 内基于 Push 的执行模型
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#5-pipelineexecutor-%e5%92%8c-pipeline-%e5%86%85%e5%9f%ba%e4%ba%8e-push-%e7%9a%84%e6%89%a7%e8%a1%8c%e6%a8%a1%e5%9e%8b aria-label=Anchor>#</a></span></h2><p>PipelineExecutor::Execute() 函数通过调用 Pipeline 中各个 PhysicalOperator 的相应接口，以 Push 的方式完成了当前 Pipeline 的执行，执行逻辑可以概括为：</p><ul><li>先调用 FetchFromSource() 从 Pipeline 的 source PhysicalOperator 中获取计算结果作为 source DataChunk，这里会调用 source 的 GetData() 接口。</li><li>再调用 ExecutePushInternal() 依次执行 Pipeline 中 operators 列表中的各个 PhysicalOperator 和最后一个 sink PhysicalOperator 完成这批数据后续的所有计算操作。对于普通 operator 会调用它的 Execute() 接口，对最后的 sink 会调用它的 Sink() 接口。PipelineExecutor::ExecutePushInternal() 可以看做是 Pipeline 内的数据消费者。</li><li>最后调用 PushFinalize() 完成当前 ExecutorTask 的执行，这里会调用 sink 的 Combine 接口，用以完成一个 ExecutorTask 结束后的收尾清理工作。</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>bool</span> <span class=n>PipelineExecutor</span><span class=o>::</span><span class=n>Execute</span><span class=p>(</span><span class=n>idx_t</span> <span class=n>max_chunks</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>D_ASSERT</span><span class=p>(</span><span class=n>pipeline</span><span class=p>.</span><span class=n>sink</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>bool</span> <span class=n>exhausted_source</span> <span class=o>=</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>auto</span> <span class=o>&amp;</span><span class=n>source_chunk</span> <span class=o>=</span> <span class=n>pipeline</span><span class=p>.</span><span class=n>operators</span><span class=p>.</span><span class=n>empty</span><span class=p>()</span> <span class=o>?</span> <span class=nl>final_chunk</span> <span class=p>:</span> <span class=o>*</span><span class=n>intermediate_chunks</span><span class=p>[</span><span class=mi>0</span><span class=p>];</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=n>idx_t</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>max_chunks</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>IsFinished</span><span class=p>())</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=n>source_chunk</span><span class=p>.</span><span class=n>Reset</span><span class=p>();</span>
</span></span><span class=line><span class=cl>        <span class=n>FetchFromSource</span><span class=p>(</span><span class=n>source_chunk</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>source_chunk</span><span class=p>.</span><span class=n>size</span><span class=p>()</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>exhausted_source</span> <span class=o>=</span> <span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>auto</span> <span class=n>result</span> <span class=o>=</span> <span class=n>ExecutePushInternal</span><span class=p>(</span><span class=n>source_chunk</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>result</span> <span class=o>==</span> <span class=n>OperatorResultType</span><span class=o>::</span><span class=n>FINISHED</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>D_ASSERT</span><span class=p>(</span><span class=n>IsFinished</span><span class=p>());</span>
</span></span><span class=line><span class=cl>            <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>exhausted_source</span> <span class=o>&amp;&amp;</span> <span class=o>!</span><span class=n>IsFinished</span><span class=p>())</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=nb>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>PushFinalize</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nb>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>PhysicalOperator 同时包含了 source、operator、sink 所需要的所有接口，各个 PhysicalOperator 需要实现对应的接口完成相应的计算逻辑。比如 partitioned hash join 因为会分成 3 个阶段分别作为 sink、operator 和 source 角色，它同时实现了所有的接口。</p><div id=6-主线程和-root-pipeline-的执行 class=anchor></div><h2 class="relative group">6. 主线程和 root Pipeline 的执行
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#6-%e4%b8%bb%e7%ba%bf%e7%a8%8b%e5%92%8c-root-pipeline-%e7%9a%84%e6%89%a7%e8%a1%8c aria-label=Anchor>#</a></span></h2><p>root Pipelines 比较特殊：在构建 Event DAG 的时候不会将这部分 Pipeline 考虑进去，这部分 Pipeline 也不会被 TaskScheduler 启动的后台线程异步执行，这部分 Pipeline 要想得到执行也需要等待所有中间 Pipeline 执行结束。</p><p>root Pipeline 的执行是主线程通过调用 PipelineExecutor 的 Execute 函数完成的。主线程通过 TaskScheduler 启动的多个后台线程，通过 Event 触发和调度新一轮 Pipeline 的 ExecutorTask，Pipeline 就能够被后台执行了。剩下的问题就是主线程如何知道中间 Pipeline 执行结束，以及如何执行 root Pipeline 拿到最终结果返回给客户端。另外各个 Pipeline 在异步执行过程中可能会遇到一些 ERROR，主线程如何及时知道这些 ERROR 并返回给客户端也是需要处理的一个问题。</p><p>主线程完成中间 Pipeline 的初始调度后，因为 root Pipeline 在中间结果没有准备好之前也不能计算，这时为了加速查询的执行最好的办法就是主线程也参与到中间 Pipeline 的执行当中去。我们看到主线程会停留在 PendingQueryResult::ExecuteInternal() 的 while 循环这里：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>unique_ptr</span><span class=o>&lt;</span><span class=n>QueryResult</span><span class=o>&gt;</span> <span class=n>PendingQueryResult</span><span class=o>::</span><span class=n>ExecuteInternal</span><span class=p>(</span><span class=n>ClientContextLock</span> <span class=o>&amp;</span><span class=n>lock</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>CheckExecutableInternal</span><span class=p>(</span><span class=n>lock</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=p>(</span><span class=n>ExecuteTaskInternal</span><span class=p>(</span><span class=n>lock</span><span class=p>)</span> <span class=o>==</span> <span class=n>PendingExecutionResult</span><span class=o>::</span><span class=n>RESULT_NOT_READY</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>HasError</span><span class=p>())</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>make_unique</span><span class=o>&lt;</span><span class=n>MaterializedQueryResult</span><span class=o>&gt;</span><span class=p>(</span><span class=n>error</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>auto</span> <span class=n>result</span> <span class=o>=</span> <span class=n>context</span><span class=o>-&gt;</span><span class=n>FetchResultInternal</span><span class=p>(</span><span class=n>lock</span><span class=p>,</span> <span class=o>*</span><span class=k>this</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>Close</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>result</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>PendingQueryResult::ExecuteTaskInternal() 经过几次函数调用后最终会来到 PipelineExecutor::Execute() 函数。这个函数初始一看可能会比较绕，但想要实现的功能是：</p><ol><li>在所有中间 Pipeline 没有执行完之前一直和后台线程一起参与计算：如果从队列中取出来了一个 ExecutorTask 就尝试调用它的 Execute(TaskExecutionMode::PROCESS_PARTIAL) 函数完成小批量数据的计算，现在默认是 50 个 DataChunk。</li><li>如果所有 Pipeline 都执行完了，此时 completed_pipelines 与 total_pipelines（记录中间 Pipeline 的数量，不包含 root Pipeline）相等，Executor 会释放所有中间 Pipeline，标记 execution_result 为PendingExecutionResult::RESULT_READY。</li></ol><p>在这个小 while 循环中，如果没有取到 task，或者执行了 Task 的小部分任务后，都会去检测其他线程执行过程中是否有 Error 产生，用户是否 cancel 了 query 等等，一旦遇到错误产生，就会分别通过 CancelTasks() 和 ThrowException() 取消后台异步 Task 的执行并将错误抛给主线程的上层。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>PendingExecutionResult</span> <span class=n>Executor</span><span class=o>::</span><span class=n>ExecuteTask</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>execution_result</span> <span class=o>!=</span> <span class=n>PendingExecutionResult</span><span class=o>::</span><span class=n>RESULT_NOT_READY</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>execution_result</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=c1>// check if there are any incomplete pipelines
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>auto</span> <span class=o>&amp;</span><span class=n>scheduler</span> <span class=o>=</span> <span class=n>TaskScheduler</span><span class=o>::</span><span class=n>GetScheduler</span><span class=p>(</span><span class=n>context</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=p>(</span><span class=n>completed_pipelines</span> <span class=o>&lt;</span> <span class=n>total_pipelines</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// there are! if we don&#39;t already have a task, fetch one
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>task</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>scheduler</span><span class=p>.</span><span class=n>GetTaskFromProducer</span><span class=p>(</span><span class=o>*</span><span class=n>producer</span><span class=p>,</span> <span class=n>task</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>task</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=c1>// if we have a task, partially process it
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=k>auto</span> <span class=n>result</span> <span class=o>=</span> <span class=n>task</span><span class=o>-&gt;</span><span class=n>Execute</span><span class=p>(</span><span class=n>TaskExecutionMode</span><span class=o>::</span><span class=n>PROCESS_PARTIAL</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=p>(</span><span class=n>result</span> <span class=o>!=</span> <span class=n>TaskExecutionResult</span><span class=o>::</span><span class=n>TASK_NOT_FINISHED</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=c1>// if the task is finished, clean it up
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=n>task</span><span class=p>.</span><span class=n>reset</span><span class=p>();</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>HasError</span><span class=p>())</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=c1>// we (partially) processed a task and no exceptions were thrown
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=c1>// give back control to the caller
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=k>return</span> <span class=n>PendingExecutionResult</span><span class=o>::</span><span class=n>RESULT_NOT_READY</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=n>execution_result</span> <span class=o>=</span> <span class=n>PendingExecutionResult</span><span class=o>::</span><span class=n>EXECUTION_ERROR</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1>// an exception has occurred executing one of the pipelines
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>// we need to cancel all tasks associated with this executor
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>CancelTasks</span><span class=p>();</span>
</span></span><span class=line><span class=cl>        <span class=n>ThrowException</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>D_ASSERT</span><span class=p>(</span><span class=o>!</span><span class=n>task</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>lock_guard</span><span class=o>&lt;</span><span class=n>mutex</span><span class=o>&gt;</span> <span class=n>elock</span><span class=p>(</span><span class=n>executor_lock</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>pipelines</span><span class=p>.</span><span class=n>clear</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=n>NextExecutor</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>HasError</span><span class=p>())</span> <span class=p>{</span> <span class=c1>// LCOV_EXCL_START
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>// an exception has occurred executing one of the pipelines
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>execution_result</span> <span class=o>=</span> <span class=n>PendingExecutionResult</span><span class=o>::</span><span class=n>EXECUTION_ERROR</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>ThrowException</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=c1>// LCOV_EXCL_STOP
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>execution_result</span> <span class=o>=</span> <span class=n>PendingExecutionResult</span><span class=o>::</span><span class=n>RESULT_READY</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>execution_result</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>一旦 execution_result 的状态变为 RESULT_READY，就意味着我们结束了所有中间 Pipeline 的执行，Executor::ExecuteTask() 会一直返回 RESULT_READY，最外层的 for 循环也会退出，从而进入下一阶段，也就是执行 root Pipeline。root Pipeline 被 Executor 所持有，它的执行也是在 Executor::FetchChunk() 中完成的：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>unique_ptr</span><span class=o>&lt;</span><span class=n>DataChunk</span><span class=o>&gt;</span> <span class=n>Executor</span><span class=o>::</span><span class=n>FetchChunk</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>D_ASSERT</span><span class=p>(</span><span class=n>physical_plan</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>auto</span> <span class=n>chunk</span> <span class=o>=</span> <span class=n>make_unique</span><span class=o>&lt;</span><span class=n>DataChunk</span><span class=o>&gt;</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=n>root_executor</span><span class=o>-&gt;</span><span class=n>InitializeChunk</span><span class=p>(</span><span class=o>*</span><span class=n>chunk</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>while</span> <span class=p>(</span><span class=nb>true</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>root_executor</span><span class=o>-&gt;</span><span class=n>ExecutePull</span><span class=p>(</span><span class=o>*</span><span class=n>chunk</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>chunk</span><span class=o>-&gt;</span><span class=n>size</span><span class=p>()</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>root_executor</span><span class=o>-&gt;</span><span class=n>PullFinalize</span><span class=p>();</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=p>(</span><span class=n>NextExecutor</span><span class=p>())</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=k>continue</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>chunk</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>虽然从函数名来看 Executor 调用了 Pipeline::ExecutePull() 函数，但其实这个函数内部实现仍旧是 push 的方式，先从 source 拿到一批数据，然后再依次的经过所有 operators 的计算得到最终结果。</p><div id=7-pipeline-的构造 class=anchor></div><h2 class="relative group">7. Pipeline 的构造
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#7-pipeline-%e7%9a%84%e6%9e%84%e9%80%a0 aria-label=Anchor>#</a></span></h2><p>Pipeline 的执行框架我们已经大概了解，最后一个问题就是 PhysicalOperator tree 是如何转换成 Pipeline DAG 的了。Pipeline 主要由 source、operators 和 sink 这三部分构成，从物理执行计划划分 Pipeline 第一个遇到的问题是如何确定 Pipeline 的 sink 和 source。</p><p>DuckDB 采用了和 Hyper 一样的 Pipeline breaker 定义：那些需要消化掉所有孩子节点的数据后才能进行下一步计算输出结果的算子。典型的比如构造 hash join 或 hash aggregate 的 hash table，或者 sort 和 TopN 算子的排序操作，需要完全消费掉孩子节点的数据 后，才能得到正确结果进行下一阶段的数据。</p><p>算子的具体实现决定了 Pipeline 的构造。物理执行计划转成 Pipeline 是由其中的各个 PhysicalOperator 完成的，几个关键函数：</p><ul><li>Executor::InitializeInternal()：把物理执行计划（PhysicalOperator tree）转成 Pipeline 的入口，所有构造出来的 Pipeline 都存储在该查询的 Executor 中。</li><li>PhysicalOperator::BuildPipelines()：构造 Pipeline 的是通过 top down 的遍历 PhysicalOperator tree 完成的，Pipeline 的 sink 会先被确定下来（要么是整个物理执行计划的根节点，要么是上一个 Pipeline 的 source 节点）。Executor 通过该函数遍历每个 PhysicalOperator，决定将其加入当前 Pipeline 的 operators 列表还是做为当前 Pipeline 的 source。遇到当前 Pipeline 的 source 时就需要结束构造当前 Pipeline 了，然后将该 source 作为下一个 Pipeline 的 sink，继续 top down 的遍历 PhysicalOperator tree 和构造新的 Pipeline。</li><li>PhysicalOperator::BuildChildPipeline()：切分 Pipeline，构造 Pipeline 之间的依赖关系。</li></ul><p>PhysicalOperator::BuildPipelines() 是个虚函数，搜索代码可以看到，像 PhysicalJoin、PhysicalRecursiveCTE、PhysicalUnion 这些有多个孩子节点的以及一些比较特殊的算子都重载了这个虚函。其他没有重载该函数的算子，默认的 BuildPipelines() 函数如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>void</span> <span class=n>PhysicalOperator</span><span class=o>::</span><span class=n>BuildPipelines</span><span class=p>(</span><span class=n>Pipeline</span> <span class=o>&amp;</span><span class=n>current</span><span class=p>,</span> <span class=n>MetaPipeline</span> <span class=o>&amp;</span><span class=n>meta_pipeline</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>op_state</span><span class=p>.</span><span class=n>reset</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>auto</span> <span class=o>&amp;</span><span class=n>state</span> <span class=o>=</span> <span class=n>meta_pipeline</span><span class=p>.</span><span class=n>GetState</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>IsSink</span><span class=p>())</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// operator is a sink, build a pipeline
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>sink_state</span><span class=p>.</span><span class=n>reset</span><span class=p>();</span>
</span></span><span class=line><span class=cl>        <span class=n>D_ASSERT</span><span class=p>(</span><span class=n>children</span><span class=p>.</span><span class=n>size</span><span class=p>()</span> <span class=o>==</span> <span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1>// single operator: the operator becomes the data source of the current pipeline
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>state</span><span class=p>.</span><span class=n>SetPipelineSource</span><span class=p>(</span><span class=n>current</span><span class=p>,</span> <span class=k>this</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1>// we create a new pipeline starting from the child
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>auto</span> <span class=n>child_meta_pipeline</span> <span class=o>=</span> <span class=n>meta_pipeline</span><span class=p>.</span><span class=n>CreateChildMetaPipeline</span><span class=p>(</span><span class=n>current</span><span class=p>,</span> <span class=k>this</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>child_meta_pipeline</span><span class=o>-&gt;</span><span class=n>Build</span><span class=p>(</span><span class=n>children</span><span class=p>[</span><span class=mi>0</span><span class=p>].</span><span class=n>get</span><span class=p>());</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// operator is not a sink! recurse in children
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>if</span> <span class=p>(</span><span class=n>children</span><span class=p>.</span><span class=n>empty</span><span class=p>())</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=c1>// source
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=n>state</span><span class=p>.</span><span class=n>SetPipelineSource</span><span class=p>(</span><span class=n>current</span><span class=p>,</span> <span class=k>this</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=p>(</span><span class=n>children</span><span class=p>.</span><span class=n>size</span><span class=p>()</span> <span class=o>!=</span> <span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=k>throw</span> <span class=nf>InternalException</span><span class=p>(</span><span class=s>&#34;Operator not supported in BuildPipelines&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>            <span class=n>state</span><span class=p>.</span><span class=n>AddPipelineOperator</span><span class=p>(</span><span class=n>current</span><span class=p>,</span> <span class=k>this</span><span class=p>);</span>
</span></span><span class=line><span class=cl>            <span class=n>children</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span><span class=o>-&gt;</span><span class=n>BuildPipelines</span><span class=p>(</span><span class=n>current</span><span class=p>,</span> <span class=n>meta_pipeline</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>PhysicalOperator::BuildPipelines() 不仅构建了 PhysicalOperator 和 Pipeline 的关系，也构建了 Pipeline 之间的依赖关系：如果某个 PhysicalOperator 是 Pipeline breaker，那么它不仅会作为当前 Pipeline 的 source，也会作为下一个 Pipeline 的 sink，Pipeline breaker 算子隐含了 Pipeline 之间的计算先后关系，只有上游 Pipeline 完全完成计算后才能开启下游 Pipeline 的计算。</p><p>一个简单的单表聚合为例，它的执行计划和对应的 Pipeline 可以表示成下图，其中 Pipeline 1 依赖 Pipeline 2：</p><p><figure><img class="my-0 rounded-md" src=/images/duckdb-push-based-execution-model/topn-and-aggregate.jpg alt="TopN and Aggregate to Pipelines"></figure></p><div id=71-从-physicalunion-构造-pipeline class=anchor></div><h3 class="relative group">7.1. 从 PhysicalUnion 构造 Pipeline
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#71-%e4%bb%8e-physicalunion-%e6%9e%84%e9%80%a0-pipeline aria-label=Anchor>#</a></span></h3><p>我们以 Union All 为例介绍一个稍微复杂有多个 child 的情况。DuckDB 的 Union All 用 PhysicalUnion 来表示，每个 PhysicalUnion 有 2 个孩子节点。如果用户 SQL 中有 N 个表 Union All，那么就会构造出 N-1 个 PhysicalUnion 算子。PhysicalUnion 仅仅用来汇总多个数据源，传递孩子节点的数据给它的父节点完成计算。</p><p>PhysicalUnion 有多个 child 数据源，意味着 PhysicalUnion 往下 top down 构造 Pipeline 的时候需要分别给各个孩子节点传递不同的 Pipeline，那这 2 个 Pipeline 的 sink 应该是什么呢。考虑到 PhysicalUnion 没有计算逻辑仅汇总数据的特殊性，DuckDB 让这 2 个 Pipeline 共享当前传递过来的 Pipeline 的 sink 和当前的 operators 列表，然后各自在自己的 operators 列表中新增自己的算子，设置自己的 sink。</p><p>这样的 Pipeline 分裂可以使 PhysicalUnion 父节点的计算逻辑和对应的中间状态在这 2 个 Pipeline 之间复用，虽然 PhysicalUnion 孩子节点的计算逻辑位于不同 Pipeline 之间各自独立产生计算结果，但 PhysicalUnion 之后的计算逻辑和中间状态在不同 Pipeline 之间是共用的，可以确保计算的正确性。</p><p>不过这样的 Pipeline 构造带来了额外的问题，我们上面提到 Pipeline breaker 确定了 Pipeline 之间的计算调度关系，并且每个 Pipeline 还可以独立设置自己的并发度。对于 PhysicalUnion 所处的 Pipeline 来说，这个 Pipeline 的 sink 同时属于多个 Pipeline（PhysicalUnion 分裂出来的），只有这些 Pipeline 都完成执行后才能执行他们的下游 Pipeline。所以后面在 Pipeline 调度的时候这里还需要特殊处理下。</p><p>一个简单的 UNION ALL 为例，它的执行计划和对应的 Pipeline 可以表示成下图：</p><p><figure><img class="my-0 rounded-md" src=/images/duckdb-push-based-execution-model/unionall.jpg alt="Union All to Pipelines"></figure></p><div id=72-从-physicaljoin-构造-pipeline class=anchor></div><h3 class="relative group">7.2. 从 PhysicalJoin 构造 Pipeline
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#72-%e4%bb%8e-physicaljoin-%e6%9e%84%e9%80%a0-pipeline aria-label=Anchor>#</a></span></h3><p>理解了 Union All 的 Pipeline 构造，我们再来看看稍微复杂点的 Join。PhysicalJoin 的 Pipeline 构造相对来说要复杂一点，需要我们先大致了解下 DuckDB 中 PhysicalJoin 的实现。</p><p>DuckDB 的 Hash Join 采用了 partitioned hash join，当数据量比较大的时候可以通过 repartition 将数据落盘避免 OOM，这个多线程版本的 partitioned hash join，主要分为 3 个阶段：</p><ol><li>并发读取和计算所有 build 端的数据，当所有数据都读完后检查总数据量是否能全部放在内存中，如果不能就将 build 端的数据 repartition，选出第一批能放在内存中的 partition 为它们构造 hash table，剩下的数据存放在磁盘上。</li><li>并发读取和计算所有 probe 端的数据，这时读上来的数据要么属于内存中的 partition，要么属于磁盘上的 partition，先把属于磁盘上的 partition 的数据落盘，用属于内存中的 partition 的数据去 probe 此时 build 端的放在内存中的 hash table，得到结果返回给上层。</li><li>并发处理磁盘上的数据：挑选一批 build 端能放入内存的 partition，构造 hash table，然后 probe 端去并发的 probe 得到结果进行下一步计算。循环这样的处理过程直到所有磁盘上的 partition 都 join 完成。</li></ol><p>这 3 个过程也分别对应了 3 个基本的 Pipeline，可以表示成下图，其中 Pipeline 2 依赖 pipeline 1，Pipeline 3 依赖 Pipeline 2：</p><p><figure><img class="my-0 rounded-md" src=/images/duckdb-push-based-execution-model/join.jpg alt="Hash Join to Pipelines"></figure></p><div id=8-duckdb-执行模式的一些感受和思考 class=anchor></div><h2 class="relative group">8. DuckDB 执行模式的一些感受和思考
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#8-duckdb-%e6%89%a7%e8%a1%8c%e6%a8%a1%e5%bc%8f%e7%9a%84%e4%b8%80%e4%ba%9b%e6%84%9f%e5%8f%97%e5%92%8c%e6%80%9d%e8%80%83 aria-label=Anchor>#</a></span></h2><div id=81-计算调度的复杂性 class=anchor></div><h3 class="relative group">8.1. 计算调度的复杂性
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#81-%e8%ae%a1%e7%ae%97%e8%b0%83%e5%ba%a6%e7%9a%84%e5%a4%8d%e6%9d%82%e6%80%a7 aria-label=Anchor>#</a></span></h3><p>这是一个最直观的感受。相比 Pull 模型，Push 模型在实现时需要多考虑如何控制 Pipeline 的计算调度，也需要考虑一个 Pipeline 内数据消费速度的问题（这个我们还没在本文涉及），这些代码增加了工程实现的复杂度，也增加了问题诊断的复杂度。</p><div id=81-pipelinebreaker-的作用 class=anchor></div><h3 class="relative group">8.1. PipelineBreaker 的作用
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#81-pipelinebreaker-%e7%9a%84%e4%bd%9c%e7%94%a8 aria-label=Anchor>#</a></span></h3><p>我喜欢把计算抽象为数据和计算两个部分，就像 CPU 的 L1 Cache 分为 L1D 和 L1I 一样，之前思考 Pipeline breaker 的时候更多是从计算性能角度，这次在思考 Pipeline 之间的依赖关系和 ExecutorTask 的调度时才意识到这个容易被忽略的地方：Pipeline 其实也反应了两个比较大的计算过程之间的先后关系。这个关系在 Volcano 模型的 Pull 中没有那么明显，只是写代码时为了保证正确性其实会应用这些依赖关系，比如 hash join 在 build side 没有结束时就不会对外返回结果。</p><div id=83-除了带来性能提升外这种并发-push-执行模型还有其他优势吗 class=anchor></div><h3 class="relative group">8.3. 除了带来性能提升外，这种并发 Push 执行模型还有其他优势吗？
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#83-%e9%99%a4%e4%ba%86%e5%b8%a6%e6%9d%a5%e6%80%a7%e8%83%bd%e6%8f%90%e5%8d%87%e5%a4%96%e8%bf%99%e7%a7%8d%e5%b9%b6%e5%8f%91-push-%e6%89%a7%e8%a1%8c%e6%a8%a1%e5%9e%8b%e8%bf%98%e6%9c%89%e5%85%b6%e4%bb%96%e4%bc%98%e5%8a%bf%e5%90%97 aria-label=Anchor>#</a></span></h3><p>从数据库、数据仓库执行引擎的经验来看，遇到最多的线上问题可以分为两类：查询跑的慢并发，以及查询吃的内存太狠导致查询自己或者进程 OOM。DuckDB 因为有了基于 ExecutorTask 的计算调度机制，我们就有机会从源头来控制：如果内存或 CPU 资源有限就少调度些 ExecutorTask 来执行。这样至少能够把查询失败的问题变成查询变慢的问题，然后查询变慢的时候再去看资源使用率满不满，这样至少能守住服务可用性的 SLO，也比较符合一般的问题排查思路。</p><div id=9-参考材料 class=anchor></div><h2 class="relative group">9. 参考材料
<span class="absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100"><a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style=text-decoration-line:none!important href=#9-%e5%8f%82%e8%80%83%e6%9d%90%e6%96%99 aria-label=Anchor>#</a></span></h2><ul><li><a href=https://github.com/duckdb/duckdb/issues/1583 target=_blank>issues/1583</a> Move to push-based execution model</li><li>Push-Based Execution in DuckDB, by Mark Raasveldt: <a href=https://dsdsd.da.cwi.nl/slides/dsdsd-duckdb-push-based-execution.pdf target=_blank>slides</a>, <a href="https://www.youtube.com/watch?v=1kDrPgRUuEI" target=_blank>video</a></li></ul></br></br></div><script>var oid="views_posts/duckdb-push-based-execution-model.md",oid_likes="likes_posts/duckdb-push-based-execution-model.md"</script><script type=text/javascript src=/js/page.min.0e49973b4ad0a382c7c6012d8bff8226316642daabc4f8a20477bd08674f3da6e2fa993bc20ad4f51e7c5bb68e6f913a207a7c4fe37ea0e7b806894afce0a64e.js integrity="sha512-DkmXO0rQo4LHxgEti/+CJjFmQtqrxPiiBHe9CGdPPabi+pk7wgrU9R58W7aOb5E6IHp8T+N+oOe4BolK/OCmTg=="></script></section><footer class="pt-8 max-w-prose print:hidden"><div class=flex><img class="!mt-0 !mb-0 h-24 w-24 rounded-full ltr:mr-4 rtl:ml-4" width=96 height=96 alt="Jian Zhang" src=/img/author_hu2e2e832894596e8fd219c1697ebbdb2b_59617_192x192_fill_q75_box_center.jpeg><div class=place-self-center><div class="text-[0.6rem] uppercase leading-3 text-neutral-500 dark:text-neutral-400">Author</div><div class="font-semibold leading-6 text-neutral-800 dark:text-neutral-300">Jian Zhang</div><div class="text-sm text-neutral-700 dark:text-neutral-400">We always overestimate the change that will occur in the next two years and underestimate the change that will occur in the next ten. Don’t let yourself be lulled into inaction</div><div class="text-2xl sm:text-lg"><div class="flex flex-wrap text-neutral-400 dark:text-neutral-500"><a class="px-1 hover:text-primary-700 dark:hover:text-primary-400" href=zjsariel@gmail.com target=_blank aria-label=Email rel="me noopener noreferrer"><span class="inline-block align-text-bottom"><span class="relative block icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentcolor" d="M207.8 20.73c-93.45 18.32-168.7 93.66-187 187.1-27.64 140.9 68.65 266.2 199.1 285.1 19.01 2.888 36.17-12.26 36.17-31.49l1e-4-.6631c0-15.74-11.44-28.88-26.84-31.24-84.35-12.98-149.2-86.13-149.2-174.2.0-102.9 88.61-185.5 193.4-175.4 91.54 8.869 158.6 91.25 158.6 183.2v16.16c0 22.09-17.94 40.05-40 40.05s-40.01-17.96-40.01-40.05v-120.1c0-8.847-7.161-16.02-16.01-16.02l-31.98.0036c-7.299.0-13.2 4.992-15.12 11.68-24.85-12.15-54.24-16.38-86.06-5.106-38.75 13.73-68.12 48.91-73.72 89.64-9.483 69.01 43.81 128 110.9 128 26.44.0 50.43-9.544 69.59-24.88 24 31.3 65.23 48.69 109.4 37.49C465.2 369.3 496 324.1 495.1 277.2V256.3c0-149.2-133.9-265.632-287.3-235.57zM239.1 304.3c-26.47.0-48-21.56-48-48.05s21.53-48.05 48-48.05 48 21.56 48 48.05-20.6 48.05-48 48.05z"/></svg></span></span></a><a class="px-1 hover:text-primary-700 dark:hover:text-primary-400" href=https://github.com/zz-jason target=_blank aria-label=Github rel="me noopener noreferrer"><span class="inline-block align-text-bottom"><span class="relative block icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><path fill="currentcolor" d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6.0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6.0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3.0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1.0-6.2-.3-40.4-.3-61.4.0.0-70 15-84.7-29.8.0.0-11.4-29.1-27.8-36.6.0.0-22.9-15.7 1.6-15.4.0.0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5.0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9.0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4.0 33.7-.3 75.4-.3 83.6.0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6.0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9.0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg></span></span></a><a class="px-1 hover:text-primary-700 dark:hover:text-primary-400" href=https://linkedin.com/in/zhangjian1012 target=_blank aria-label=Linkedin rel="me noopener noreferrer"><span class="inline-block align-text-bottom"><span class="relative block icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path fill="currentcolor" d="M416 32H31.9C14.3 32 0 46.5.0 64.3v383.4C0 465.5 14.3 480 31.9 480H416c17.6.0 32-14.5 32-32.3V64.3c0-17.8-14.4-32.3-32-32.3zM135.4 416H69V202.2h66.5V416zm-33.2-243c-21.3.0-38.5-17.3-38.5-38.5S80.9 96 102.2 96c21.2.0 38.5 17.3 38.5 38.5.0 21.3-17.2 38.5-38.5 38.5zm282.1 243h-66.4V312c0-24.8-.5-56.7-34.5-56.7-34.6.0-39.9 27-39.9 54.9V416h-66.4V202.2h63.7v29.2h.9c8.9-16.8 30.6-34.5 62.9-34.5 67.2.0 79.7 44.3 79.7 101.9V416z"/></svg></span></span></a><a class="px-1 hover:text-primary-700 dark:hover:text-primary-400" href=https://twitter.com/zhangjian1012 target=_blank aria-label=Twitter rel="me noopener noreferrer"><span class="inline-block align-text-bottom"><span class="relative block icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentcolor" d="M459.37 151.716c.325 4.548.325 9.097.325 13.645.0 138.72-105.583 298.558-298.558 298.558-59.452.0-114.68-17.219-161.137-47.106 8.447.974 16.568 1.299 25.34 1.299 49.055.0 94.213-16.568 130.274-44.832-46.132-.975-84.792-31.188-98.112-72.772 6.498.974 12.995 1.624 19.818 1.624 9.421.0 18.843-1.3 27.614-3.573-48.081-9.747-84.143-51.98-84.143-102.985v-1.299c13.969 7.797 30.214 12.67 47.431 13.319-28.264-18.843-46.781-51.005-46.781-87.391.0-19.492 5.197-37.36 14.294-52.954 51.655 63.675 129.3 105.258 216.365 109.807-1.624-7.797-2.599-15.918-2.599-24.04.0-57.828 46.782-104.934 104.934-104.934 30.213.0 57.502 12.67 76.67 33.137 23.715-4.548 46.456-13.32 66.599-25.34-7.798 24.366-24.366 44.833-46.132 57.827 21.117-2.273 41.584-8.122 60.426-16.243-14.292 20.791-32.161 39.308-52.628 54.253z"/></svg></span></span></a></div></div></div></div><div class=pt-8><hr class="border-dotted border-neutral-300 dark:border-neutral-600"><div class="flex justify-between pt-3"><span><a class="flex group mr-3" href=/posts/2021-books/><span class="mr-3 text-neutral-700 group-hover:text-primary-600 ltr:inline rtl:hidden dark:text-neutral dark:group-hover:text-primary-400">&larr;</span>
<span class="ml-3 text-neutral-700 group-hover:text-primary-600 ltr:hidden rtl:inline dark:text-neutral dark:group-hover:text-primary-400">&rarr;</span>
<span class="flex flex-col"><span class="mt-[0.1rem] leading-6 group-hover:underline group-hover:decoration-primary-500">2021 读书总结</span>
<span class="mt-[0.1rem] text-xs text-neutral-500 dark:text-neutral-400"><time datetime="2022-01-28 02:41:56 +0000 UTC">28 January 2022</time></span></span></a></span>
<span><a class="flex text-right group ml-3" href=/posts/sigmod-2001-orthogonal-optimization-of-subqueries-and-aggregation/><span class="flex flex-col"><span class="mt-[0.1rem] leading-6 group-hover:underline group-hover:decoration-primary-500">[SIGMOD 2001] Orthogonal Optimization of Subqueries and Aggregation</span>
<span class="mt-[0.1rem] text-xs text-neutral-500 dark:text-neutral-400"><time datetime="2022-11-25 13:47:11 +0000 UTC">25 November 2022</time></span></span>
<span class="ml-3 text-neutral-700 group-hover:text-primary-600 ltr:inline rtl:hidden dark:text-neutral dark:group-hover:text-primary-400">&rarr;</span>
<span class="mr-3 text-neutral-700 group-hover:text-primary-600 ltr:hidden rtl:inline dark:text-neutral dark:group-hover:text-primary-400">&larr;</span></a></span></div></div><div class=pt-3><hr class="border-dotted border-neutral-300 dark:border-neutral-600"><div class=pt-3><script src=https://utteranc.es/client.js repo=zz-jason/zz-jason.github.io issue-term=pathname theme=github-dark crossorigin=anonymous async></script></div></div></footer></article><div id=top-scroller class="pointer-events-none absolute top-[110vh] bottom-0 w-12 ltr:right-0 rtl:left-0"><a href=#the-top class="pointer-events-auto sticky top-[calc(100vh-5.5rem)] flex h-12 w-12 mb-16 items-center justify-center rounded-full bg-neutral/50 text-xl text-neutral-700 backdrop-blur hover:text-primary-600 dark:bg-neutral-800/50 dark:text-neutral dark:hover:text-primary-400" aria-label="Scroll to top" title="Scroll to top">&uarr;</a></div></main><footer id=site-footer class="py-10 print:hidden"><div class="flex items-center justify-between"><p class="text-sm text-neutral-500 dark:text-neutral-400">@2023 Jian Zhang</p><p class="text-xs text-neutral-500 dark:text-neutral-400">Powered by <a class="hover:underline hover:decoration-primary-400 hover:text-primary-500" href=https://gohugo.io/ target=_blank rel="noopener noreferrer">Hugo</a> & <a class="hover:underline hover:decoration-primary-400 hover:text-primary-500" href=https://blowfish.page/ target=_blank rel="noopener noreferrer">Blowfish</a></p></div><script>mediumZoom(document.querySelectorAll("img:not(.nozoom)"),{margin:24,background:"rgba(0,0,0,0.5)",scrollOffset:0})</script><script type=text/javascript src=/js/process.min.35c1113bcc16c5a59bf031082f9e63822aa95280423881a7847a7ff33a16e6299ce6a840d9ef4e10d947e030a18f3f20359afb2ec0f35967484b9a9360ac3145.js integrity="sha512-NcERO8wWxaWb8DEIL55jgiqpUoBCOIGnhHp/8zoW5imc5qhA2e9OENlH4DChjz8gNZr7LsDzWWdIS5qTYKwxRQ=="></script></footer></div></body></html>