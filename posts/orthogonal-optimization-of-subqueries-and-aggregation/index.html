<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>[SIGMOD 2001] Orthogonal Optimization of Subqueries and Aggregation | Jian Zhang</title><meta name=keywords content><meta name=description content="SQL 优化中，索引选择、Join Reorder、子查询优化是最难处理的几个问题。这是一篇 2001 年（距今 21 年了，时间过得好快）发表的经典论文，提出了 Apply"><meta name=author content="Jian"><link rel=canonical href=https://zz-jason.github.io/posts/orthogonal-optimization-of-subqueries-and-aggregation/><link href=/assets/css/stylesheet.min.bdb03579c17662815eb277a528f9b9b67a014d2778e9fb0aa5489aa14f7b2643.css integrity="sha256-vbA1ecF2YoFesnelKPm5tnoBTSd46fsKpUiaoU97JkM=" rel="preload stylesheet" as=style><link rel=icon href=https://zz-jason.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://zz-jason.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://zz-jason.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://zz-jason.github.io/apple-touch-icon.png><link rel=mask-icon href=https://zz-jason.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.80.0"><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-67872953-1','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><meta property="og:title" content="[SIGMOD 2001] Orthogonal Optimization of Subqueries and Aggregation"><meta property="og:description" content="SQL 优化中，索引选择、Join Reorder、子查询优化是最难处理的几个问题。这是一篇 2001 年（距今 21 年了，时间过得好快）发表的经典论文，提出了 Apply"><meta property="og:type" content="article"><meta property="og:url" content="https://zz-jason.github.io/posts/orthogonal-optimization-of-subqueries-and-aggregation/"><meta property="article:published_time" content="2022-11-25T13:47:11+00:00"><meta property="article:modified_time" content="2022-11-25T13:47:11+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="[SIGMOD 2001] Orthogonal Optimization of Subqueries and Aggregation"><meta name=twitter:description content="SQL 优化中，索引选择、Join Reorder、子查询优化是最难处理的几个问题。这是一篇 2001 年（距今 21 年了，时间过得好快）发表的经典论文，提出了 Apply"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://zz-jason.github.io/posts/"},{"@type":"ListItem","position":2,"name":"[SIGMOD 2001] Orthogonal Optimization of Subqueries and Aggregation","item":"https://zz-jason.github.io/posts/orthogonal-optimization-of-subqueries-and-aggregation/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"[SIGMOD 2001] Orthogonal Optimization of Subqueries and Aggregation","name":"[SIGMOD 2001] Orthogonal Optimization of Subqueries and Aggregation","description":"SQL 优化中，索引选择、Join Reorder、子查询优化是最难处理的几个问题。这是一篇 2001 年（距今 21 年了，时间过得好快）发表的经典论文，提出了 Apply","keywords":[],"articleBody":"SQL 优化中，索引选择、Join Reorder、子查询优化是最难处理的几个问题。这是一篇 2001 年（距今 21 年了，时间过得好快）发表的经典论文，提出了 Apply 算子和一种渐进式、迭代式的子查询去关联和优化的方法。不少数据库的子查询处理都采用了类似的思路，我觉得这篇论文最有价值的地方在于对问题的分治，体现在这些方面：\n 通过引入 Apply 算子将子查询问题独立出来，通过一系列原子的优化规则，将子查询去关联的问题划分成一个个 Apply 消除和下推的小问题，在代码实现上结合 Volcano/Cascades 优化框架可以很好的控制代码复杂度，提高代码的可理解性和可维护性。论文最后还提到一种 Segmented Apply 算子，能够消除某种模式的重复 Table Scan 来提供更好的执行性能。 Apply 下推和消除的过程中其他 SQL 算子也会遇到新的优化机会，比如论文提到的聚合下推、上拉、Outer Join 化简成 Inner Join 等，这些复杂问题也可以通过分治的思想由一系列小的优化规则逐个解决。  近期因为工作原因重温了这篇论文，这次我把其中一些比较关键的原理和思考整理出来，希望能帮助到大家。\n子查询和常用执行策略 Apply 算子的定义 文章在 1.3 小结给出了 Apply 算子的形式化定义如下，Apply 的语义启发自 LISP，简单来说可以看做是一个 nested loop join：外层驱动表先读取一行数据，然后执行内部的 subquery。和普通 Join 算子一样，Apply 连接左右两表的方式可以是 cross join、left outer join、left semi join、 left anti join 等，只要能产生满足 SQL 语义的正确结果就行。\n下面的例子讲述了 SQL 子查询和 Apply 的转换关系：\n它转换出来的 Apply 算子如下：\n如果 Apply 里面没有关联子查询，它其实等价于 nested loop join。Apply 算子的执行过程大致如下：\n  读取一行驱动表的数据，上面例子是 CUSTOMER 表。\n  根据该行驱动表的数据更新 Apply 算子所在子树的关联变量，上面例子中，假设读取上来的一行数据中 C_CUSTKEY 得值是 123，那么 O_CUSTKEY=C_CUSTKEY 绑定上这个运行时读上来的值后就变成了 O_CUSTKEY=123 这样的 filter。\n  执行 Apply 算子得到结果，返回给更上层的 SQL 算子。在上面的例子中，O_CUSTKEY=C_CUSTKEY 的 C_CUSTKEY 被更新后，Apply 算子为根的子 plan 就可以独立执行返回结果了。经过 SGb（scala group by，没有 group by key 仅返回一行结果的 group by 算子）得到一行数据，和外层 CUSTOMER 的这一行数据 join 后也仅产生一行数据，然后经过后续的 1000000 了解了 Apply 算子的定义，那如何通过 Apply 算子进行子查询的优化和执行呢。要完成子查询优化，我们需要先将 AST 转换成 Apply 算子。Appy 算子本身是可以执行的，但通常如果内表没有索引，或者外表的数据量非常大，Apply 的执行效率会非常低，所以还需要进行 Apply 相关的优化，尽量将 Apply 转换成没有关联子查询的普通 Join，然后利用现有的 Join 优化规则进行更进一步的查询优化。\n将 AST 改写成包含 Apply 的执行计划 子查询会出现在 SQL 的各个地方，但通常都是发生在表达式计算的时候，比如上面例子，在构造 WHERE 子句的 SELECT 算子时发现一个 scalar expression 内嵌了一个 subquery，这个 subquery expression 里的 statement 描述了这个 subquery 代表的 scalar value 是如何计算出来的。\nApply 改写的基本思路比较简单，只需要在使用这个 Subquery 的 SQL 算子之前构造好为其提供 Subquery 结果的 Apply 算子即可。在上面这个例子中，我们需要在 SELECT 算子之前构造好 Apply，执行计划变成：CUSTOMER - Apply - Select，其中 CUSTOMER 作为 Apply 算子的左子树，而 Subuquery 里的语句构造出来的执行计划作为 Apply 的右子树，原先在 SELECT 中的子查询也根据需要替换成其他等价的 scalar expression，比如当 Apply 是 left outer join 时，IN Subquery 就可以替换成对右孩子（代表子查询执行结果）某个字段的 IS NOT NULL 函数。\n考虑到一方面子查询可能嵌套，另一方面一个 scalar expression 也可能包含多个子查询，而且我们在改写完子查询后还需要替换成新的 scalar expression，因此最好采用 Bottom Up 的方式递归的构造子查询对应的 Apply 算子和新的用于替代当前它的新的 scalar expression：\n  Bottom-Up 的遍历 expression 树，如果发现 child expression 已经被改写了，就更新其 child 信息\n  遍历自己，如果需要进行子查询改写，则根据子查询的类型生成相应的 Apply 算子和改写后的新 expression。构造 Apply 时将当前 subquery expression 所在 SQL 算子的 child operator 作为新 Apply 算子的左孩子，子查询对应的 plan 作为新 Apply 算子的右孩子，根据 scalar expression 的语义选择适当的 join 类型（left outer join、cross join 等）。新的 scalar expression 使用构造出来的 Apply 算子所产生的结果做为输入。\n  通过这样 Bottom-Up 的遍历后，我们就得到了最终的 Apply 算子和需要替换的 scalar expression，然后继续遍历 AST 的其他部分，构造剩余的 query plan，完成从 AST 到执行计划的转化。\n因为整个过程是递归的，每个子查询都会遍历到并转换成相应的 Apply 算子和 scalar expression，当这种方法应用到包含多个子查询的场景时，最终会生成一棵类似下面这样的 Apply 左深树：\nIN、NOT IN 的改写 IN 可以改写成 Distinct + Apply：先通过 Apply 计算出 Left Outer Join 的结果，然后将 Selection 中的子查询改为 Apply 产生的右表上的 column 的 IsNotNull 表达式即可。如果是 NOT IN 就改写成 IsNull。\n比如 where t.id in (select id from s) 就改写成了：\n对子查询的结果加 Distinct 去重是为了确保驱动表的数据经过 left outer join 后不会发生膨胀，如果能 Join 上则只会有一条数据产生，如果没有 Join 上则会把右表部分填补成 NULL 后也产生一条结果。因此 Apply 的输出结果里有完整的左表数据，我们也能根据输出结果中右表部分的数据是否为 NULL 来判断是否 Join 上（也就是 IN 子查询的结果应该是 true 还是 false）。\nEXISTS、NOT EXISTS 的改写 和上面 IN、NOT IN 大致相同。\ncompare predicate 的改写 保留原本的 compare operator，把相关的 parameter 用子查询的结果替换。子查询根据需要改写成 Aggregate 或者 MaxOneRow（新算子，用于确保用户没有写 group by 但是又要求结果只产生一行数据的情况）\nApply 的下推和消除 下面是论文给出的所有 Apply 消除会用到的原子优化规则。SQL Server 采用了 Volcano/Cascades 优化框架，每个优化规则只需要匹配一个 Plan 片段即可，因此 Apply 下推直至消除所需要使用的优化规则都可以一遍遍的应用到新产生的执行计划中，直至优化结束：\n这些公式看起来复杂，但理解起来还是比较容易的，可以把他们分为 2 类：一类是直接消除 Apply 算子的，可以认为是 Apply 消除算法的终止条件，另一类就是不断进行 Apply 下推寻找 Apply 消除机会的，我们分别来介绍他们。\n规则 1、2：Apply 消除 规则 1：当 Apply 的左表和右表没有任何 join 条件时，不管这是个什么 join（cross join、left outer join, left semi join、left anti join），都可以将 Apply 转换成普通 Join 算子。\n规则 2：对 Apply 而言，右孩子的 Filter 可以等价转换成 Apply 的 join 条件，完成这次转换后，Apply 就和普通 nested loop join 没有什么区别了，可以安全的将其转换成普通 Join 算子。\n需要注意的是：\n 规则 1 和 2 能够生效的公共条件是 Apply 的右孩子中，E 为根的执行计划中不包含 R 中的相关列。 理论上来说 Apply 转换后的执行计划不一定什么情况下都更好，比如当左表的数据量很小，右表在相关联列上有索引，或者右表已经提前物化到了计算节点上时，可能 Apply 算子这种 nested loop 的执行方式会更好。这个之前在 TiDB 的一些客户场景中遇见过一些。保险的做法是把 Apply 算子代表的老执行计划也留下来，通过 CBO 来选择。当然怎么样让 CBO 选择更准确就是另一个难题了。  规则 3 - 9：Apply 下推，寻找消除的机会 规则 1 和 2 描述了 Apply 消除的终止条件，而规则 3-9 则描述了在各个场景下 Apply 如何下推，行成可以触发规则 1 和 2 的执行计划。\n 规则 3 和 4 分别描述了 Apply 下推过 selection 和 pojection 的场景 规则 5 和和 6 分别描述了 Apply 下推过 union [all] 和 intersect [all] 的场景 规则 7 描述了 Apply 下推过 cross join 的场景，需要注意的是：  下推后 R 表在左右两个 Apply 算子中分别被读了 1 次，如果底层没有采用 DAG 的 execution model 使得 R 表可以只读一次被多个 parent 复用可能会有很大的性能损耗，使得下推后的 Apply 不如下推前执行效率好。 下推后取代原始 Apply 的是一个 inner join，为了确保 R 表的每行数据仍然只会产生一行结果，这个 inner join 的 equal condition 需要在 R 表的某个唯一索引、主键或者其他可以唯一决定一行数据的字段上（比如 row id）。   规则 8-9 分别描述了 Apply 下推过 vector aggregation 和 scalar aggregation 的场景。  因为下推过 Aggregation 后要确保 R 的每行数据只产生一行结果，我们需要保证新产生的 Aggregation 的 group by key 也是某个能唯一确定 R 表一行数据的主键、唯一索引、或者类似 row id 一样的字段。 另外对于规则 9 来说，先后的 aggregation 分别是 scalar aggregation 和 vector aggregation，需要特别注意某些聚合函数对 empty set input 和 null input 的结果差异。    Apply 下推和消除的例子 Apply 引发的其他优化 在子查询改写成 Apply 算子，以及 Apply 算子下推、消除的过程中，会诞生聚合和 Join 算子，因此也引发了其他的优化规则。我们先来看看聚合的上拉和下推。\n聚合的上拉和下推 Outer Join 化简 Segemented Apply ","wordCount":"3377","inLanguage":"en","datePublished":"2022-11-25T13:47:11Z","dateModified":"2022-11-25T13:47:11Z","author":{"@type":"Person","name":"Jian"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://zz-jason.github.io/posts/orthogonal-optimization-of-subqueries-and-aggregation/"},"publisher":{"@type":"Organization","name":"Jian Zhang","logo":{"@type":"ImageObject","url":"https://zz-jason.github.io/favicon.ico"}}}</script></head><body id=top><noscript><style type=text/css>#theme-toggle,.top-link{display:none}</style></noscript><header class=header><nav class=nav><div class=logo><a href=https://zz-jason.github.io/ accesskey=h title="Jian Zhang (Alt + H)">Jian Zhang</a>
<span class=logo-switches></span></div><ul id=menu onscroll=menu_on_scroll()><li><a href=https://zz-jason.github.io/ title=Home><span>Home</span></a></li><li><a href=https://zz-jason.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://zz-jason.github.io/posts/ title=Archives><span>Archives</span></a></li><li><a href=https://zz-jason.github.io/about/ title=About><span>About</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>[SIGMOD 2001] Orthogonal Optimization of Subqueries and Aggregation</h1><div class=post-meta>November 25, 2022&nbsp;·&nbsp;7 min&nbsp;·&nbsp;Jian</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><div class=details>Table of Contents</div></summary><div class=inner><ul><li><a href=#%e5%ad%90%e6%9f%a5%e8%af%a2%e5%92%8c%e5%b8%b8%e7%94%a8%e6%89%a7%e8%a1%8c%e7%ad%96%e7%95%a5 aria-label=子查询和常用执行策略>子查询和常用执行策略</a></li><li><a href=#apply-%e7%ae%97%e5%ad%90%e7%9a%84%e5%ae%9a%e4%b9%89 aria-label="Apply 算子的定义">Apply 算子的定义</a></li><li><a href=#%e5%b0%86-ast-%e6%94%b9%e5%86%99%e6%88%90%e5%8c%85%e5%90%ab-apply-%e7%9a%84%e6%89%a7%e8%a1%8c%e8%ae%a1%e5%88%92 aria-label="将 AST 改写成包含 Apply 的执行计划">将 AST 改写成包含 Apply 的执行计划</a><ul><li><a href=#innot-in-%e7%9a%84%e6%94%b9%e5%86%99 aria-label="IN、NOT IN 的改写">IN、NOT IN 的改写</a></li><li><a href=#existsnot-exists-%e7%9a%84%e6%94%b9%e5%86%99 aria-label="EXISTS、NOT EXISTS 的改写">EXISTS、NOT EXISTS 的改写</a></li><li><a href=#compare-predicate-%e7%9a%84%e6%94%b9%e5%86%99 aria-label="compare predicate 的改写">compare predicate 的改写</a></li></ul></li><li><a href=#apply-%e7%9a%84%e4%b8%8b%e6%8e%a8%e5%92%8c%e6%b6%88%e9%99%a4 aria-label="Apply 的下推和消除">Apply 的下推和消除</a><ul><li><a href=#%e8%a7%84%e5%88%99-12apply-%e6%b6%88%e9%99%a4 aria-label="规则 1、2：Apply 消除">规则 1、2：Apply 消除</a></li><li><a href=#%e8%a7%84%e5%88%99-3---9apply-%e4%b8%8b%e6%8e%a8%e5%af%bb%e6%89%be%e6%b6%88%e9%99%a4%e7%9a%84%e6%9c%ba%e4%bc%9a aria-label="规则 3 - 9：Apply 下推，寻找消除的机会">规则 3 - 9：Apply 下推，寻找消除的机会</a></li><li><a href=#apply-%e4%b8%8b%e6%8e%a8%e5%92%8c%e6%b6%88%e9%99%a4%e7%9a%84%e4%be%8b%e5%ad%90 aria-label="Apply 下推和消除的例子">Apply 下推和消除的例子</a></li></ul></li><li><a href=#apply-%e5%bc%95%e5%8f%91%e7%9a%84%e5%85%b6%e4%bb%96%e4%bc%98%e5%8c%96 aria-label="Apply 引发的其他优化">Apply 引发的其他优化</a><ul><li><a href=#%e8%81%9a%e5%90%88%e7%9a%84%e4%b8%8a%e6%8b%89%e5%92%8c%e4%b8%8b%e6%8e%a8 aria-label=聚合的上拉和下推>聚合的上拉和下推</a></li><li><a href=#outer-join-%e5%8c%96%e7%ae%80 aria-label="Outer Join 化简">Outer Join 化简</a></li></ul></li><li><a href=#segemented-apply aria-label="Segemented Apply">Segemented Apply</a></li></ul></div></details></div><div class=post-content><p>SQL 优化中，索引选择、Join Reorder、子查询优化是最难处理的几个问题。这是一篇 2001 年（距今 21 年了，时间过得好快）发表的经典论文，提出了 Apply 算子和一种渐进式、迭代式的子查询去关联和优化的方法。不少数据库的子查询处理都采用了类似的思路，我觉得这篇论文最有价值的地方在于对问题的分治，体现在这些方面：</p><ol><li>通过引入 Apply 算子将子查询问题独立出来，通过一系列原子的优化规则，将子查询去关联的问题划分成一个个 Apply 消除和下推的小问题，在代码实现上结合 Volcano/Cascades 优化框架可以很好的控制代码复杂度，提高代码的可理解性和可维护性。论文最后还提到一种 Segmented Apply 算子，能够消除某种模式的重复 Table Scan 来提供更好的执行性能。</li><li>Apply 下推和消除的过程中其他 SQL 算子也会遇到新的优化机会，比如论文提到的聚合下推、上拉、Outer Join 化简成 Inner Join 等，这些复杂问题也可以通过分治的思想由一系列小的优化规则逐个解决。</li></ol><p>近期因为工作原因重温了这篇论文，这次我把其中一些比较关键的原理和思考整理出来，希望能帮助到大家。</p><h2 id=子查询和常用执行策略>子查询和常用执行策略<a hidden class=anchor aria-hidden=true href=#子查询和常用执行策略>#</a></h2><h2 id=apply-算子的定义>Apply 算子的定义<a hidden class=anchor aria-hidden=true href=#apply-算子的定义>#</a></h2><p>文章在 1.3 小结给出了 Apply 算子的形式化定义如下，Apply 的语义启发自 LISP，简单来说可以看做是一个 nested loop join：外层驱动表先读取一行数据，然后执行内部的 subquery。和普通 Join 算子一样，Apply 连接左右两表的方式可以是 cross join、left outer join、left semi join、 left anti join 等，只要能产生满足 SQL 语义的正确结果就行。</p><p><img src=/images/orthogonal-optimization-of-subqueries-and-aggregation/apply.png alt=Apply></p><p>下面的例子讲述了 SQL 子查询和 Apply 的转换关系：</p><p><img src=/images/orthogonal-optimization-of-subqueries-and-aggregation/q1.png alt=Q1></p><p>它转换出来的 Apply 算子如下：</p><p><img src=/images/orthogonal-optimization-of-subqueries-and-aggregation/subquery-execution-using-apply.png alt="Subquery Execution Using Apply"></p><p>如果 Apply 里面没有关联子查询，它其实等价于 nested loop join。Apply 算子的执行过程大致如下：</p><ol><li><p>读取一行驱动表的数据，上面例子是 CUSTOMER 表。</p></li><li><p>根据该行驱动表的数据更新 Apply 算子所在子树的关联变量，上面例子中，假设读取上来的一行数据中 C_CUSTKEY 得值是 123，那么 O_CUSTKEY=C_CUSTKEY 绑定上这个运行时读上来的值后就变成了 O_CUSTKEY=123 这样的 filter。</p></li><li><p>执行 Apply 算子得到结果，返回给更上层的 SQL 算子。在上面的例子中，O_CUSTKEY=C_CUSTKEY 的 C_CUSTKEY 被更新后，Apply 算子为根的子 plan 就可以独立执行返回结果了。经过 SGb（scala group by，没有 group by key 仅返回一行结果的 group by 算子）得到一行数据，和外层 CUSTOMER 的这一行数据 join 后也仅产生一行数据，然后经过后续的 1000000&lt;x 的过滤条件，完成后续计算。</p></li></ol><p>了解了 Apply 算子的定义，那如何通过 Apply 算子进行子查询的优化和执行呢。要完成子查询优化，我们需要先将 AST 转换成 Apply 算子。Appy 算子本身是可以执行的，但通常如果内表没有索引，或者外表的数据量非常大，Apply 的执行效率会非常低，所以还需要进行 Apply 相关的优化，尽量将 Apply 转换成没有关联子查询的普通 Join，然后利用现有的 Join 优化规则进行更进一步的查询优化。</p><h2 id=将-ast-改写成包含-apply-的执行计划>将 AST 改写成包含 Apply 的执行计划<a hidden class=anchor aria-hidden=true href=#将-ast-改写成包含-apply-的执行计划>#</a></h2><p><img src=/images/orthogonal-optimization-of-subqueries-and-aggregation/ast.png alt=AST></p><p>子查询会出现在 SQL 的各个地方，但通常都是发生在表达式计算的时候，比如上面例子，在构造 WHERE 子句的 SELECT 算子时发现一个 scalar expression 内嵌了一个 subquery，这个 subquery expression 里的 statement 描述了这个 subquery 代表的 scalar value 是如何计算出来的。</p><p>Apply 改写的基本思路比较简单，只需要在使用这个 Subquery 的 SQL 算子之前构造好为其提供 Subquery 结果的 Apply 算子即可。在上面这个例子中，我们需要在 SELECT 算子之前构造好 Apply，执行计划变成：CUSTOMER -> Apply -> Select，其中 CUSTOMER 作为 Apply 算子的左子树，而 Subuquery 里的语句构造出来的执行计划作为 Apply 的右子树，原先在 SELECT 中的子查询也根据需要替换成其他等价的 scalar expression，比如当 Apply 是 left outer join 时，IN Subquery 就可以替换成对右孩子（代表子查询执行结果）某个字段的 IS NOT NULL 函数。</p><p>考虑到一方面子查询可能嵌套，另一方面一个 scalar expression 也可能包含多个子查询，而且我们在改写完子查询后还需要替换成新的 scalar expression，因此最好采用 Bottom Up 的方式递归的构造子查询对应的 Apply 算子和新的用于替代当前它的新的 scalar expression：</p><ol><li><p>Bottom-Up 的遍历 expression 树，如果发现 child expression 已经被改写了，就更新其 child 信息</p></li><li><p>遍历自己，如果需要进行子查询改写，则根据子查询的类型生成相应的 Apply 算子和改写后的新 expression。构造 Apply 时将当前 subquery expression 所在 SQL 算子的 child operator 作为新 Apply 算子的左孩子，子查询对应的 plan 作为新 Apply 算子的右孩子，根据 scalar expression 的语义选择适当的 join 类型（left outer join、cross join 等）。新的 scalar expression 使用构造出来的 Apply 算子所产生的结果做为输入。</p></li></ol><p>通过这样 Bottom-Up 的遍历后，我们就得到了最终的 Apply 算子和需要替换的 scalar expression，然后继续遍历 AST 的其他部分，构造剩余的 query plan，完成从 AST 到执行计划的转化。</p><p>因为整个过程是递归的，每个子查询都会遍历到并转换成相应的 Apply 算子和 scalar expression，当这种方法应用到包含多个子查询的场景时，最终会生成一棵类似下面这样的 Apply 左深树：</p><p><img src=/images/orthogonal-optimization-of-subqueries-and-aggregation/left-deep-tree.png alt="Left Deep Tree"></p><h3 id=innot-in-的改写>IN、NOT IN 的改写<a hidden class=anchor aria-hidden=true href=#innot-in-的改写>#</a></h3><p>IN 可以改写成 Distinct + Apply：先通过 Apply 计算出 Left Outer Join 的结果，然后将 Selection 中的子查询改为 Apply 产生的右表上的 column 的 IsNotNull 表达式即可。如果是 NOT IN 就改写成 IsNull。</p><p>比如 where t.id in (select id from s) 就改写成了：</p><p><img src=/images/orthogonal-optimization-of-subqueries-and-aggregation/in-subq.png alt="In Sub-Query"></p><p>对子查询的结果加 Distinct 去重是为了确保驱动表的数据经过 left outer join 后不会发生膨胀，如果能 Join 上则只会有一条数据产生，如果没有 Join 上则会把右表部分填补成 NULL 后也产生一条结果。因此 Apply 的输出结果里有完整的左表数据，我们也能根据输出结果中右表部分的数据是否为 NULL 来判断是否 Join 上（也就是 IN 子查询的结果应该是 true 还是 false）。</p><h3 id=existsnot-exists-的改写>EXISTS、NOT EXISTS 的改写<a hidden class=anchor aria-hidden=true href=#existsnot-exists-的改写>#</a></h3><p>和上面 IN、NOT IN 大致相同。</p><h3 id=compare-predicate-的改写>compare predicate 的改写<a hidden class=anchor aria-hidden=true href=#compare-predicate-的改写>#</a></h3><p>保留原本的 compare operator，把相关的 parameter 用子查询的结果替换。子查询根据需要改写成 Aggregate 或者 MaxOneRow（新算子，用于确保用户没有写 group by 但是又要求结果只产生一行数据的情况）</p><h2 id=apply-的下推和消除>Apply 的下推和消除<a hidden class=anchor aria-hidden=true href=#apply-的下推和消除>#</a></h2><p>下面是论文给出的所有 Apply 消除会用到的原子优化规则。SQL Server 采用了 Volcano/Cascades 优化框架，每个优化规则只需要匹配一个 Plan 片段即可，因此 Apply 下推直至消除所需要使用的优化规则都可以一遍遍的应用到新产生的执行计划中，直至优化结束：</p><p><img src=/images/orthogonal-optimization-of-subqueries-and-aggregation/rules.png alt=Rules></p><p>这些公式看起来复杂，但理解起来还是比较容易的，可以把他们分为 2 类：一类是直接消除 Apply 算子的，可以认为是 Apply 消除算法的终止条件，另一类就是不断进行 Apply 下推寻找 Apply 消除机会的，我们分别来介绍他们。</p><h3 id=规则-12apply-消除>规则 1、2：Apply 消除<a hidden class=anchor aria-hidden=true href=#规则-12apply-消除>#</a></h3><p>规则 1：当 Apply 的左表和右表没有任何 join 条件时，不管这是个什么 join（cross join、left outer join, left semi join、left anti join），都可以将 Apply 转换成普通 Join 算子。</p><p>规则 2：对 Apply 而言，右孩子的 Filter 可以等价转换成 Apply 的 join 条件，完成这次转换后，Apply 就和普通 nested loop join 没有什么区别了，可以安全的将其转换成普通 Join 算子。</p><p>需要注意的是：</p><ol><li>规则 1 和 2 能够生效的公共条件是 Apply 的右孩子中，E 为根的执行计划中不包含 R 中的相关列。</li><li>理论上来说 Apply 转换后的执行计划不一定什么情况下都更好，比如当左表的数据量很小，右表在相关联列上有索引，或者右表已经提前物化到了计算节点上时，可能 Apply 算子这种 nested loop 的执行方式会更好。这个之前在 TiDB 的一些客户场景中遇见过一些。保险的做法是把 Apply 算子代表的老执行计划也留下来，通过 CBO 来选择。当然怎么样让 CBO 选择更准确就是另一个难题了。</li></ol><h3 id=规则-3---9apply-下推寻找消除的机会>规则 3 - 9：Apply 下推，寻找消除的机会<a hidden class=anchor aria-hidden=true href=#规则-3---9apply-下推寻找消除的机会>#</a></h3><p>规则 1 和 2 描述了 Apply 消除的终止条件，而规则 3-9 则描述了在各个场景下 Apply 如何下推，行成可以触发规则 1 和 2 的执行计划。</p><ol><li>规则 3 和 4 分别描述了 Apply 下推过 selection 和 pojection 的场景</li><li>规则 5 和和 6 分别描述了 Apply 下推过 union [all] 和 intersect [all] 的场景</li><li>规则 7 描述了 Apply 下推过 cross join 的场景，需要注意的是：<ol><li>下推后 R 表在左右两个 Apply 算子中分别被读了 1 次，如果底层没有采用 DAG 的 execution model 使得 R 表可以只读一次被多个 parent 复用可能会有很大的性能损耗，使得下推后的 Apply 不如下推前执行效率好。</li><li>下推后取代原始 Apply 的是一个 inner join，为了确保 R 表的每行数据仍然只会产生一行结果，这个 inner join 的 equal condition 需要在 R 表的某个唯一索引、主键或者其他可以唯一决定一行数据的字段上（比如 row id）。</li></ol></li><li>规则 8-9 分别描述了 Apply 下推过 vector aggregation 和 scalar aggregation 的场景。<ol><li>因为下推过 Aggregation 后要确保 R 的每行数据只产生一行结果，我们需要保证新产生的 Aggregation 的 group by key 也是某个能唯一确定 R 表一行数据的主键、唯一索引、或者类似 row id 一样的字段。</li><li>另外对于规则 9 来说，先后的 aggregation 分别是 scalar aggregation 和 vector aggregation，需要特别注意某些聚合函数对 empty set input 和 null input 的结果差异。</li></ol></li></ol><h3 id=apply-下推和消除的例子>Apply 下推和消除的例子<a hidden class=anchor aria-hidden=true href=#apply-下推和消除的例子>#</a></h3><p><img src=/images/orthogonal-optimization-of-subqueries-and-aggregation/example.png alt=Example></p><h2 id=apply-引发的其他优化>Apply 引发的其他优化<a hidden class=anchor aria-hidden=true href=#apply-引发的其他优化>#</a></h2><p>在子查询改写成 Apply 算子，以及 Apply 算子下推、消除的过程中，会诞生聚合和 Join 算子，因此也引发了其他的优化规则。我们先来看看聚合的上拉和下推。</p><h3 id=聚合的上拉和下推>聚合的上拉和下推<a hidden class=anchor aria-hidden=true href=#聚合的上拉和下推>#</a></h3><h3 id=outer-join-化简>Outer Join 化简<a hidden class=anchor aria-hidden=true href=#outer-join-化简>#</a></h3><h2 id=segemented-apply>Segemented Apply<a hidden class=anchor aria-hidden=true href=#segemented-apply>#</a></h2></div><footer class=post-footer><nav class=paginav><a class=next href=https://zz-jason.github.io/posts/duckdb-push-based-execution-model/><span class=title>Next Page »</span><br><span>[DuckDB] Push-Based Execution Model</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share [SIGMOD 2001] Orthogonal Optimization of Subqueries and Aggregation on twitter" href="https://twitter.com/intent/tweet/?text=%5bSIGMOD%202001%5d%20Orthogonal%20Optimization%20of%20Subqueries%20and%20Aggregation&url=https%3a%2f%2fzz-jason.github.io%2fposts%2forthogonal-optimization-of-subqueries-and-aggregation%2f&hashtags="><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512h-386.892c-34.524.0-62.554-28.03-62.554-62.554v-386.892c0-34.524 28.029-62.554 62.554-62.554h386.892zm-253.927 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share [SIGMOD 2001] Orthogonal Optimization of Subqueries and Aggregation on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fzz-jason.github.io%2fposts%2forthogonal-optimization-of-subqueries-and-aggregation%2f&title=%5bSIGMOD%202001%5d%20Orthogonal%20Optimization%20of%20Subqueries%20and%20Aggregation&summary=%5bSIGMOD%202001%5d%20Orthogonal%20Optimization%20of%20Subqueries%20and%20Aggregation&source=https%3a%2f%2fzz-jason.github.io%2fposts%2forthogonal-optimization-of-subqueries-and-aggregation%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512h-386.892c-34.524.0-62.554-28.03-62.554-62.554v-386.892c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0v-129.439c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02v-126.056c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768h75.024zm-307.552-334.556c-25.674.0-42.448 16.879-42.448 39.002.0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share [SIGMOD 2001] Orthogonal Optimization of Subqueries and Aggregation on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fzz-jason.github.io%2fposts%2forthogonal-optimization-of-subqueries-and-aggregation%2f&title=%5bSIGMOD%202001%5d%20Orthogonal%20Optimization%20of%20Subqueries%20and%20Aggregation"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512h-386.892c-34.524.0-62.554-28.03-62.554-62.554v-386.892c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zm-119.474 108.193c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zm-160.386-29.702c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share [SIGMOD 2001] Orthogonal Optimization of Subqueries and Aggregation on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fzz-jason.github.io%2fposts%2forthogonal-optimization-of-subqueries-and-aggregation%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978v-192.915h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554v-386.892c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share [SIGMOD 2001] Orthogonal Optimization of Subqueries and Aggregation on whatsapp" href="https://api.whatsapp.com/send?text=%5bSIGMOD%202001%5d%20Orthogonal%20Optimization%20of%20Subqueries%20and%20Aggregation%20-%20https%3a%2f%2fzz-jason.github.io%2fposts%2forthogonal-optimization-of-subqueries-and-aggregation%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512h-386.892c-34.524.0-62.554-28.03-62.554-62.554v-386.892c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23-13.314-11.876-22.304-26.542-24.916-31.026s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share [SIGMOD 2001] Orthogonal Optimization of Subqueries and Aggregation on telegram" href="https://telegram.me/share/url?text=%5bSIGMOD%202001%5d%20Orthogonal%20Optimization%20of%20Subqueries%20and%20Aggregation&url=https%3a%2f%2fzz-jason.github.io%2fposts%2forthogonal-optimization-of-subqueries-and-aggregation%2f"><svg viewBox="2 2 28 28"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47A3.38 3.38.0 0126.49 29.86zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer><script src=https://utteranc.es/client.js repo=zz-jason/zz-jason.github.io issue-term=pathname theme=github-light crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2022 <a href=https://zz-jason.github.io/>Jian Zhang</a></span>
<span>&#183;</span>
<span>Powered by <a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a></span>
<span>&#183;</span>
<span>Theme <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)"><button class=top-link id=top-link type=button accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></button></a>
<script defer src=/assets/js/highlight.min.27cd435cc9ed6abb4b496581b151804f79f366c412620272bb94e2f5f598ebcc.js integrity="sha256-J81DXMntartLSWWBsVGAT3nzZsQSYgJyu5Ti9fWY68w=" onload=hljs.initHighlightingOnLoad();></script><script>window.onload=function(){if(localStorage.getItem("menu-scroll-position")){document.getElementById('menu').scrollLeft=localStorage.getItem("menu-scroll-position");}}
document.querySelectorAll('a[href^="#"]').forEach(anchor=>{anchor.addEventListener("click",function(e){e.preventDefault();var id=this.getAttribute("href").substr(1);if(!window.matchMedia('(prefers-reduced-motion: reduce)').matches){document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({behavior:"smooth"});}else{document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();}
if(id==="top"){history.replaceState(null,null," ");}else{history.pushState(null,null,`#${id}`);}});});var mybutton=document.getElementById("top-link");window.onscroll=function(){if(document.body.scrollTop>800||document.documentElement.scrollTop>800){mybutton.style.visibility="visible";mybutton.style.opacity="1";}else{mybutton.style.visibility="hidden";mybutton.style.opacity="0";}};function menu_on_scroll(){localStorage.setItem("menu-scroll-position",document.getElementById('menu').scrollLeft);}</script></body></html>