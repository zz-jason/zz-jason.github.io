<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>[VLDB 2023] Scalable and Robust Latches for Database Systems | Jian Zhang</title><meta name=keywords content><meta name=description content="Introduction 虽然编程语言和各类库中有许多不同的锁实现，但是却没有人详细研究过什么样的锁适用于数据库的工作负载，主要原因是数据库的工作负载范围很广，有 write-heavy"><meta name=author content="Jian"><link rel=canonical href=https://zz-jason.github.io/posts/vldb-2023-scalable-and-robust-latches/><link href=/assets/css/stylesheet.min.770d8a0aa405dcf691d11ff1ae1a3ef7f461eed00172c15620f8b0f1e5c77e8f.css integrity="sha256-dw2KCqQF3PaR0R/xrho+9/Rh7tABcsFWIPiw8eXHfo8=" rel="preload stylesheet" as=style><link rel=icon href=https://zz-jason.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://zz-jason.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://zz-jason.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://zz-jason.github.io/apple-touch-icon.png><link rel=mask-icon href=https://zz-jason.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.110.0"><script type=application/javascript>var doNotTrack=!1;doNotTrack||(window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-67872953-1","auto"),ga("send","pageview"))</script><script async src=https://www.google-analytics.com/analytics.js></script><meta property="og:title" content="[VLDB 2023] Scalable and Robust Latches for Database Systems"><meta property="og:description" content="Introduction 虽然编程语言和各类库中有许多不同的锁实现，但是却没有人详细研究过什么样的锁适用于数据库的工作负载，主要原因是数据库的工作负载范围很广，有 write-heavy"><meta property="og:type" content="article"><meta property="og:url" content="https://zz-jason.github.io/posts/vldb-2023-scalable-and-robust-latches/"><meta property="article:published_time" content="2023-04-18T00:00:00+00:00"><meta property="article:modified_time" content="2023-04-18T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="[VLDB 2023] Scalable and Robust Latches for Database Systems"><meta name=twitter:description content="Introduction 虽然编程语言和各类库中有许多不同的锁实现，但是却没有人详细研究过什么样的锁适用于数据库的工作负载，主要原因是数据库的工作负载范围很广，有 write-heavy"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://zz-jason.github.io/posts/"},{"@type":"ListItem","position":2,"name":"[VLDB 2023] Scalable and Robust Latches for Database Systems","item":"https://zz-jason.github.io/posts/vldb-2023-scalable-and-robust-latches/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"[VLDB 2023] Scalable and Robust Latches for Database Systems","name":"[VLDB 2023] Scalable and Robust Latches for Database Systems","description":"Introduction 虽然编程语言和各类库中有许多不同的锁实现，但是却没有人详细研究过什么样的锁适用于数据库的工作负载，主要原因是数据库的工作负载范围很广，有 write-heavy","keywords":[],"articleBody":"Introduction 虽然编程语言和各类库中有许多不同的锁实现，但是却没有人详细研究过什么样的锁适用于数据库的工作负载，主要原因是数据库的工作负载范围很广，有 write-heavy 的 OLTP 事务，也有 read-only 的 OLAP 查询，甚至还有两者都涉及的 HTAP 负载。\n这篇论文不长，主要讲了一个面向数据库使用场景的 Hybrid Lock，它能同时提供乐观和悲观这两种上锁方式，使得数据库可以在不同的场景中使用不同的上锁方式以获取更高的性能。本文主要描述这个 Hybrid Lock 的核心实现，论文中对其他锁的讨论对我们设计系统也很有启发意义，建议感兴趣的朋友阅读一下原论文。\nLock requirements 作者分析了数据库对锁的能力要求，总结如下：并发读需要尽量快，尽量在多核上 scale，因为包括 OLTP 事务在内的大多数工作负载都是以读为主。对那些采用了代码生成的系统来说，也需要尽量避免外部函数调用。因为锁可能保护非常细粒度的数据结构，因此锁本身的空间开销也应该尽量小。需要尽量高效优雅的处理锁冲突，对于数据库来说，可能线程在锁等待时用户已经取消了查询执行，好的锁实现最好也支持锁等待的线程周期性的检查这类事件，及时响应用户的取消操作。\nOptimistic and pessimistic locking 作者将上锁的方式分为 2 种：乐观上锁和悲观上锁。\n悲观锁：可以根据 “悲观” 这个词来顾名思义，认为这次操作大概率会和其他并发线程产生冲突，在操作数据前先以共享或互斥的方式上锁，线程之间的锁冲突可以在操作数据之前检测到。比如使用常见的 RwLock，在操作数据前先上 Read Lock 或 Write Lock，只有上锁成功后才操作数据。\n乐观锁：也可以同样顾名思义，认为这次操作大概率不会和其他线程产生冲突，所以干脆不上锁，而是采用原子变量的方式为保护的数据维护了一个版本号。数据被修改版本号会增加，这样读这个数据的线程只需对比版本号是否发生变化，如果检测到冲突，就重试这次读操作。\n上面是实现一个乐观锁的伪代码。读的时候如果发现编码在版本号中的 lock 比特位为 1（表明有人在更新数据），或者读取数据后版本号发生了变化（表明数据已经更新了），这次读操作就需要重试。乐观锁特别适合用在经常读的热点数据上，比如 B Tree 的 root 节点。使用时需要注意几个问题：\nOptimistic locking 在碰到写的时候会重试正在进行的读操作，需要确保重试时不会发生异常。比如读取某个 B Tree 节点，可能别的线程触发了 B Tree Merge 操作导致当前要读的节点被删除了，需要确保重试时访问这个节点不会出现访问 null pointer 的情况。 注意上面伪代码传入的是一个 readCallBack，这个 callback 每次重试都会被调用，如果在里面更新一些值，比如求 count，那么可能就会因为重试得到错误结果。最安全的做法是仅通过这个 callback 获取数据，等整个读操作返回后才用读到的值去做下一步的计算。 当很多线程并发写时，乐观锁很容易被饿死，所以就像伪代码描述的那样，在经历了最大重试次数后需要能够 fallback 到悲观锁。 乐观锁和悲观锁的性能差异主要来自 cache coherence。从上面伪代码可以看出，乐观锁不会修改原子变量的值，这使得各个 CPU core 上的 cache line 一直有效。而悲观锁则因为这些修改操作使得其他 CPU cache 频频失效，导致性能很差。\nHybrid lock 作者将不同场景和对应的最佳的上锁方式整理到了上表中，可以看到除了 read-only 和重试代价低的 read-mostly 场景，其他 3 种场景需要采用 shared 或 exclusive 的悲观锁才能获得最佳性能。\n作者提出采用 HybridLock，希望能够根据上下文使用不同的上锁方式，在所有场景都获得最好的性能。比如 B Tree，访问 read-contended 上层节点时就可以使用乐观锁，而访问叶子结点去读取数据时就最好使用悲观锁以避免代价高昂的冲突重试。\n为了达到这个目标，作者设计了一个 Hybrid Lock。如上图所示，这个 Hybrid Lock 内部包含一个 RWMutex 和一个 atomic 分别用来实现悲观锁和乐观锁，Hybrid Lock 的伪代码如下所示：\n需要特别注意 unlockExclusive() 里面两个操作的顺序。因为 tryReadOptimistically() 在执行完 readCallBack 后先检查 RWMutex 再检查 version，unlockExclusive() 里面就需要先 version +1 再释放 RWMutex，确保读操作获取到 RWMutex 后对应的 version 已经更新了，这样它才一定能够检测到这个读写冲突并重试。也可以使用 Intel 的 CMPXCHG16B 指令来同时更新 version 和释放锁。\nreadOptimisticIfPossible() 和一开始在乐观锁实现中看到的伪代码稍微有点区别。它会在 tryReadOptimistically() 失败后直接从回退到悲观锁，使用 lockShared() 和 unLockShared() 完成这次读操作。\n作者在 “2.2 Speculative Locking (HTM)” 中也介绍了 Speculative Locking (HTM) 这类硬件支持的琐实现，没有采用它们是因为它们仅在特殊硬件支持，还不够通用。\nRWMutex and contention handling 上面的 Hybrid Lock 还不能完全满足数据库场景的需求，比如在使用普通 RWMutex 时，如果一个线程被锁阻塞，它就会一直阻塞在那，而阻塞过程中用户发起的 cancel query 请求就可能因为长时间的锁等待而迟迟没有被响应。于是 Hybrid Lock 还需要一种能更好的处理锁冲突的 RWMutex 实现。\n“3.1 Busy-Waiting/Spinning”、“3.2 Local Spinning using Queuing” 和 “3.3 Ticket Spinlock” 中作者详细介绍和分析了 spinlock 和它的一些变种。整体而言，没有采用它们的原因是希望避免 spinlock 带来的 priority inversion、wastes resources and energy 以及 cache pollution 的问题。\n没有采用 spinlock，作者参考 webkit 自己设计和实现了一个叫 ParkingLot 的 RWMutex。\nParkingLot 像 pthread mutex 这类琐实现通常都通过内核系统调用来挂起当前线程直到获得锁为止。但内核的系统调用开销很高，所以也有像 Linux 的 futex 这样的自适应锁实现，仅在锁冲突时才调用内核阻塞当前线程。基于 futex 的思路，WebKit 提出了一个叫 ParkingLot 的自适应锁，也就是这篇论文采用的锁实现。这种实现方式非常通用，可移植性强。\n如上图所示，ParkingLot 有 3 个关键要素：\nlock：为方便理解，我们可以认为它是一个 64 位整数的原子变量，在 ParkingLot 中只使用它的两个比特位，分别是 L 位用来表示是否有线程以 exclusive 的方式持有锁，以及 W 位表示是否有线程在锁等待（发生在某个其他线程以 exclusive 的方式持有锁时）。 ParkingSpace：每个锁都有一个 ParkingSpace，里面存储了 3 个数据。一个是 WaitingThreads 表示有多少线程正在锁等待，一个是条件变量用来挂起或唤醒当前线程，另一是传统的 mutex 用来保护这个 ParkSpace 本身的并发访问（比如修改 WaitingThreads） ParkingLot：lock 地址到对应 ParkingSpace 的全局哈希表。因为冲突的锁数量最多不会超过使用的线程数，ParkingLot 里只有固定的 512 个槽位就足够了，采用拉链法解决哈希冲突。 这种锁实现非常灵活，比如可以在锁等待时可以执行某个 callback。Umbra 就是利用这个特性在锁等待时检查查询是否被取消，Page 是否已经被缓存替换等。\n上图的 ParkingLot 例子中，当前锁的 L 位为 1 表示已经被其他线程持有。当另一个线程想再次获取锁时，它会在 ParkingLot 中等待。此时它会把锁的 W 位设置为 1 表示有人正在等锁，然后使用这个锁的地址在哈希表中找到该锁对应的 ParkingSpace，然后执行 ParkingSpace 中的逻辑。当第 1 个线程释放锁后，它发现 W 位为 1 有其他线程在等锁，它会找到这个锁的 ParkingSpace，利用里面的条件变量将等待的线程唤醒。\n上面是发现 W 位为 1 进行等待时要执行的 park 函数伪代码。在 park 的过程中，先通过锁地址 lockAddr 找到对应的 parkingSpace，把 parkingSpace 的等待线程数 +1，如果没有设置锁等待超时时间，就直接 wait 到被唤醒，然后执行 callback 根据情况看是否继续 wait。如果设置了锁等待超时时间，会每隔 timeoutInMs 唤醒一次，执行 callback，根据情况看是否需要继续 wait。callback 由调用方提供，比如检查查询是否取消就可以实现在这个 callback 中，这样在锁还没获取到但用户已经取消查询的情况下，当前线程就不用继续等待，直接退出执行。\n不过仔细 review 这个伪代码，除了检查 callback，应该还需要检查 lock 的 W 列判断锁是否还在才行，不然可能 callback 返回结果一直为 false，这个线程一直执行 while 循环，wait 到世界末日。\nTakeaways 以前对锁的使用仅局限于 RWLock，或者干脆 Lock，思维几乎固化：读写场景用 RWLock，纯写场景用 Lock。这篇论文让我对锁有了新的认知，HybridLock 的设计确实很巧妙。我想不止数据库，HybridLock 应该也能用在许多其他应用场景中，降低请求延迟，提升系统吞吐。\n","wordCount":"3209","inLanguage":"en","datePublished":"2023-04-18T00:00:00Z","dateModified":"2023-04-18T00:00:00Z","author":{"@type":"Person","name":"Jian"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://zz-jason.github.io/posts/vldb-2023-scalable-and-robust-latches/"},"publisher":{"@type":"Organization","name":"Jian Zhang","logo":{"@type":"ImageObject","url":"https://zz-jason.github.io/favicon.ico"}}}</script></head><body id=top><noscript><style type=text/css>#theme-toggle,.top-link{display:none}</style></noscript><header class=header><nav class=nav><div class=logo><a href=https://zz-jason.github.io/ accesskey=h title="Jian Zhang (Alt + H)">Jian Zhang</a>
<span class=logo-switches></span></div><ul id=menu onscroll=menu_on_scroll()><li><a href=https://zz-jason.github.io/ title=Home><span>Home</span></a></li><li><a href=https://zz-jason.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://zz-jason.github.io/posts/ title=Archives><span>Archives</span></a></li><li><a href=https://zz-jason.github.io/about/ title=About><span>About</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>[VLDB 2023] Scalable and Robust Latches for Database Systems</h1><div class=post-meta>April 18, 2023&nbsp;·&nbsp;7 min&nbsp;·&nbsp;Jian</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><div class=details>Table of Contents</div></summary><div class=inner><ul><li><a href=#introduction aria-label=Introduction>Introduction</a></li><li><a href=#lock-requirements aria-label="Lock requirements">Lock requirements</a></li><li><a href=#optimistic-and-pessimistic-locking aria-label="Optimistic and pessimistic locking">Optimistic and pessimistic locking</a></li><li><a href=#hybrid-lock aria-label="Hybrid lock">Hybrid lock</a></li><li><a href=#rwmutex-and-contention-handling aria-label="RWMutex and contention handling">RWMutex and contention handling</a><ul><li><a href=#parkinglot aria-label=ParkingLot>ParkingLot</a></li></ul></li><li><a href=#takeaways aria-label=Takeaways>Takeaways</a></li></ul></div></details></div><div class=post-content><h2 id=introduction>Introduction<a hidden class=anchor aria-hidden=true href=#introduction>#</a></h2><p>虽然编程语言和各类库中有许多不同的锁实现，但是却没有人详细研究过什么样的锁适用于数据库的工作负载，主要原因是数据库的工作负载范围很广，有 write-heavy 的 OLTP 事务，也有 read-only 的 OLAP 查询，甚至还有两者都涉及的 HTAP 负载。</p><p>这篇论文不长，主要讲了一个面向数据库使用场景的 Hybrid Lock，它能同时提供乐观和悲观这两种上锁方式，使得数据库可以在不同的场景中使用不同的上锁方式以获取更高的性能。本文主要描述这个 Hybrid Lock 的核心实现，论文中对其他锁的讨论对我们设计系统也很有启发意义，建议感兴趣的朋友阅读一下原论文。</p><h2 id=lock-requirements>Lock requirements<a hidden class=anchor aria-hidden=true href=#lock-requirements>#</a></h2><p>作者分析了数据库对锁的能力要求，总结如下：并发读需要尽量快，尽量在多核上 scale，因为包括 OLTP 事务在内的大多数工作负载都是以读为主。对那些采用了代码生成的系统来说，也需要尽量避免外部函数调用。因为锁可能保护非常细粒度的数据结构，因此锁本身的空间开销也应该尽量小。需要尽量高效优雅的处理锁冲突，对于数据库来说，可能线程在锁等待时用户已经取消了查询执行，好的锁实现最好也支持锁等待的线程周期性的检查这类事件，及时响应用户的取消操作。</p><h2 id=optimistic-and-pessimistic-locking>Optimistic and pessimistic locking<a hidden class=anchor aria-hidden=true href=#optimistic-and-pessimistic-locking>#</a></h2><p>作者将上锁的方式分为 2 种：乐观上锁和悲观上锁。</p><p>悲观锁：可以根据 “悲观” 这个词来顾名思义，认为这次操作大概率会和其他并发线程产生冲突，在操作数据前先以共享或互斥的方式上锁，线程之间的锁冲突可以在操作数据之前检测到。比如使用常见的 RwLock，在操作数据前先上 Read Lock 或 Write Lock，只有上锁成功后才操作数据。</p><p>乐观锁：也可以同样顾名思义，认为这次操作大概率不会和其他线程产生冲突，所以干脆不上锁，而是采用原子变量的方式为保护的数据维护了一个版本号。数据被修改版本号会增加，这样读这个数据的线程只需对比版本号是否发生变化，如果检测到冲突，就重试这次读操作。</p><p><img src=https://raw.githubusercontent.com/zz-jason/blog-images/master/images/202304052144085.png alt=https://raw.githubusercontent.com/zz-jason/blog-images/master/images/202304052144085.png></p><p>上面是实现一个乐观锁的伪代码。读的时候如果发现编码在版本号中的 lock 比特位为 1（表明有人在更新数据），或者读取数据后版本号发生了变化（表明数据已经更新了），这次读操作就需要重试。乐观锁特别适合用在经常读的热点数据上，比如 B Tree 的 root 节点。使用时需要注意几个问题：</p><ol><li>Optimistic locking 在碰到写的时候会重试正在进行的读操作，需要确保重试时不会发生异常。比如读取某个 B Tree 节点，可能别的线程触发了 B Tree Merge 操作导致当前要读的节点被删除了，需要确保重试时访问这个节点不会出现访问 null pointer 的情况。</li><li>注意上面伪代码传入的是一个 readCallBack，这个 callback 每次重试都会被调用，如果在里面更新一些值，比如求 count，那么可能就会因为重试得到错误结果。最安全的做法是仅通过这个 callback 获取数据，等整个读操作返回后才用读到的值去做下一步的计算。</li><li>当很多线程并发写时，乐观锁很容易被饿死，所以就像伪代码描述的那样，在经历了最大重试次数后需要能够 fallback 到悲观锁。</li></ol><p>乐观锁和悲观锁的性能差异主要来自 <a href=https://en.wikipedia.org/wiki/Cache_coherence>cache coherence</a>。从上面伪代码可以看出，乐观锁不会修改原子变量的值，这使得各个 CPU core 上的 cache line 一直有效。而悲观锁则因为这些修改操作使得其他 CPU cache 频频失效，导致性能很差。</p><h2 id=hybrid-lock>Hybrid lock<a hidden class=anchor aria-hidden=true href=#hybrid-lock>#</a></h2><p><img src=https://raw.githubusercontent.com/zz-jason/blog-images/master/images/202304062216400.png alt=https://raw.githubusercontent.com/zz-jason/blog-images/master/images/202304062216400.png></p><p>作者将不同场景和对应的最佳的上锁方式整理到了上表中，可以看到除了 read-only 和重试代价低的 read-mostly 场景，其他 3 种场景需要采用 shared 或 exclusive 的悲观锁才能获得最佳性能。</p><p>作者提出采用 HybridLock，希望能够根据上下文使用不同的上锁方式，在所有场景都获得最好的性能。比如 B Tree，访问 read-contended 上层节点时就可以使用乐观锁，而访问叶子结点去读取数据时就最好使用悲观锁以避免代价高昂的冲突重试。</p><p><img src=https://raw.githubusercontent.com/zz-jason/blog-images/master/images/202304062235593.png alt=https://raw.githubusercontent.com/zz-jason/blog-images/master/images/202304062235593.png></p><p>为了达到这个目标，作者设计了一个 Hybrid Lock。如上图所示，这个 Hybrid Lock 内部包含一个 RWMutex 和一个 atomic&lt;uint64_t> 分别用来实现悲观锁和乐观锁，Hybrid Lock 的伪代码如下所示：</p><p><img src=https://raw.githubusercontent.com/zz-jason/blog-images/master/images/202304052230691.png alt=https://raw.githubusercontent.com/zz-jason/blog-images/master/images/202304052230691.png></p><p>需要特别注意 unlockExclusive() 里面两个操作的顺序。因为 tryReadOptimistically() 在执行完 readCallBack 后先检查 RWMutex 再检查 version，unlockExclusive() 里面就需要先 version +1 再释放 RWMutex，确保读操作获取到 RWMutex 后对应的 version 已经更新了，这样它才一定能够检测到这个读写冲突并重试。也可以使用 Intel 的 <code>CMPXCHG16B</code> 指令来同时更新 version 和释放锁。</p><p>readOptimisticIfPossible() 和一开始在乐观锁实现中看到的伪代码稍微有点区别。它会在 tryReadOptimistically() 失败后直接从回退到悲观锁，使用 lockShared() 和 unLockShared() 完成这次读操作。</p><p>作者在 “2.2 Speculative Locking (HTM)” 中也介绍了 Speculative Locking (HTM) 这类硬件支持的琐实现，没有采用它们是因为它们仅在特殊硬件支持，还不够通用。</p><h2 id=rwmutex-and-contention-handling>RWMutex and contention handling<a hidden class=anchor aria-hidden=true href=#rwmutex-and-contention-handling>#</a></h2><p>上面的 Hybrid Lock 还不能完全满足数据库场景的需求，比如在使用普通 RWMutex 时，如果一个线程被锁阻塞，它就会一直阻塞在那，而阻塞过程中用户发起的 cancel query 请求就可能因为长时间的锁等待而迟迟没有被响应。于是 Hybrid Lock 还需要一种能更好的处理锁冲突的 RWMutex 实现。</p><p>“3.1 Busy-Waiting/Spinning”、“3.2 Local Spinning using Queuing” 和 “3.3 Ticket Spinlock” 中作者详细介绍和分析了 spinlock 和它的一些变种。整体而言，没有采用它们的原因是希望避免 spinlock 带来的 priority inversion、wastes resources and energy 以及 cache pollution 的问题。</p><p>没有采用 spinlock，作者参考 webkit 自己设计和实现了一个叫 ParkingLot 的 RWMutex。</p><h3 id=parkinglot>ParkingLot<a hidden class=anchor aria-hidden=true href=#parkinglot>#</a></h3><p>像 pthread mutex 这类琐实现通常都通过内核系统调用来挂起当前线程直到获得锁为止。但内核的系统调用开销很高，所以也有像 Linux 的 futex 这样的自适应锁实现，仅在锁冲突时才调用内核阻塞当前线程。基于 futex 的思路，WebKit 提出了一个叫 ParkingLot 的自适应锁，也就是这篇论文采用的锁实现。这种实现方式非常通用，可移植性强。</p><p><img src=https://raw.githubusercontent.com/zz-jason/blog-images/master/images/202304061355223.png alt=https://raw.githubusercontent.com/zz-jason/blog-images/master/images/202304061355223.png></p><p>如上图所示，ParkingLot 有 3 个关键要素：</p><ol><li>lock：为方便理解，我们可以认为它是一个 64 位整数的原子变量，在 ParkingLot 中只使用它的两个比特位，分别是 L 位用来表示是否有线程以 exclusive 的方式持有锁，以及 W 位表示是否有线程在锁等待（发生在某个其他线程以 exclusive 的方式持有锁时）。</li><li>ParkingSpace：每个锁都有一个 ParkingSpace，里面存储了 3 个数据。一个是 WaitingThreads 表示有多少线程正在锁等待，一个是条件变量用来挂起或唤醒当前线程，另一是传统的 mutex 用来保护这个 ParkSpace 本身的并发访问（比如修改 WaitingThreads）</li><li>ParkingLot：lock 地址到对应 ParkingSpace 的全局哈希表。因为冲突的锁数量最多不会超过使用的线程数，ParkingLot 里只有固定的 512 个槽位就足够了，采用拉链法解决哈希冲突。</li></ol><p>这种锁实现非常灵活，比如可以在锁等待时可以执行某个 callback。Umbra 就是利用这个特性在锁等待时检查查询是否被取消，Page 是否已经被缓存替换等。</p><p>上图的 ParkingLot 例子中，当前锁的 L 位为 1 表示已经被其他线程持有。当另一个线程想再次获取锁时，它会在 ParkingLot 中等待。此时它会把锁的 W 位设置为 1 表示有人正在等锁，然后使用这个锁的地址在哈希表中找到该锁对应的 ParkingSpace，然后执行 ParkingSpace 中的逻辑。当第 1 个线程释放锁后，它发现 W 位为 1 有其他线程在等锁，它会找到这个锁的 ParkingSpace，利用里面的条件变量将等待的线程唤醒。</p><p><img src=https://raw.githubusercontent.com/zz-jason/blog-images/master/images/202304061357401.png alt=https://raw.githubusercontent.com/zz-jason/blog-images/master/images/202304061357401.png></p><p>上面是发现 W 位为 1 进行等待时要执行的 park 函数伪代码。在 park 的过程中，先通过锁地址 lockAddr 找到对应的 parkingSpace，把 parkingSpace 的等待线程数 +1，如果没有设置锁等待超时时间，就直接 wait 到被唤醒，然后执行 callback 根据情况看是否继续 wait。如果设置了锁等待超时时间，会每隔 timeoutInMs 唤醒一次，执行 callback，根据情况看是否需要继续 wait。callback 由调用方提供，比如检查查询是否取消就可以实现在这个 callback 中，这样在锁还没获取到但用户已经取消查询的情况下，当前线程就不用继续等待，直接退出执行。</p><p>不过仔细 review 这个伪代码，除了检查 callback，应该还需要检查 lock 的 W 列判断锁是否还在才行，不然可能 callback 返回结果一直为 false，这个线程一直执行 while 循环，wait 到世界末日。</p><h2 id=takeaways>Takeaways<a hidden class=anchor aria-hidden=true href=#takeaways>#</a></h2><p>以前对锁的使用仅局限于 RWLock，或者干脆 Lock，思维几乎固化：读写场景用 RWLock，纯写场景用 Lock。这篇论文让我对锁有了新的认知，HybridLock 的设计确实很巧妙。我想不止数据库，HybridLock 应该也能用在许多其他应用场景中，降低请求延迟，提升系统吞吐。</p></div><footer class=post-footer><nav class=paginav><a class=next href=https://zz-jason.github.io/posts/sigmod-2020-rethink-log-checkpoint-recover/><span class=title>Next Page »</span><br><span>[SIGMOD 2020] Rethinking Logging, Checkpoints, and Recovery for High-Performance Storage Engines</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share [VLDB 2023] Scalable and Robust Latches for Database Systems on twitter" href="https://twitter.com/intent/tweet/?text=%5bVLDB%202023%5d%20Scalable%20and%20Robust%20Latches%20for%20Database%20Systems&url=https%3a%2f%2fzz-jason.github.io%2fposts%2fvldb-2023-scalable-and-robust-latches%2f&hashtags="><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share [VLDB 2023] Scalable and Robust Latches for Database Systems on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fzz-jason.github.io%2fposts%2fvldb-2023-scalable-and-robust-latches%2f&title=%5bVLDB%202023%5d%20Scalable%20and%20Robust%20Latches%20for%20Database%20Systems&summary=%5bVLDB%202023%5d%20Scalable%20and%20Robust%20Latches%20for%20Database%20Systems&source=https%3a%2f%2fzz-jason.github.io%2fposts%2fvldb-2023-scalable-and-robust-latches%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share [VLDB 2023] Scalable and Robust Latches for Database Systems on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fzz-jason.github.io%2fposts%2fvldb-2023-scalable-and-robust-latches%2f&title=%5bVLDB%202023%5d%20Scalable%20and%20Robust%20Latches%20for%20Database%20Systems"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share [VLDB 2023] Scalable and Robust Latches for Database Systems on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fzz-jason.github.io%2fposts%2fvldb-2023-scalable-and-robust-latches%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share [VLDB 2023] Scalable and Robust Latches for Database Systems on whatsapp" href="https://api.whatsapp.com/send?text=%5bVLDB%202023%5d%20Scalable%20and%20Robust%20Latches%20for%20Database%20Systems%20-%20https%3a%2f%2fzz-jason.github.io%2fposts%2fvldb-2023-scalable-and-robust-latches%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share [VLDB 2023] Scalable and Robust Latches for Database Systems on telegram" href="https://telegram.me/share/url?text=%5bVLDB%202023%5d%20Scalable%20and%20Robust%20Latches%20for%20Database%20Systems&url=https%3a%2f%2fzz-jason.github.io%2fposts%2fvldb-2023-scalable-and-robust-latches%2f"><svg viewBox="2 2 28 28"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer><script src=https://utteranc.es/client.js repo=zz-jason/zz-jason.github.io issue-term=pathname theme=github-light crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2023 <a href=https://zz-jason.github.io/>Jian Zhang</a></span>
<span>&#183;</span>
<span>Powered by <a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a></span>
<span>&#183;</span>
<span>Theme <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)"><button class=top-link id=top-link type=button accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></button></a>
<script defer src=/assets/js/highlight.min.b95bacdc39e37a332a9f883b1e78be4abc1fdca2bc1f2641f55e3cd3dabd4d61.js integrity="sha256-uVus3DnjejMqn4g7Hni+Srwf3KK8HyZB9V4809q9TWE=" onload=hljs.initHighlightingOnLoad()></script>
<script>window.onload=function(){localStorage.getItem("menu-scroll-position")&&(document.getElementById("menu").scrollLeft=localStorage.getItem("menu-scroll-position"))},document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})});var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")};function menu_on_scroll(){localStorage.setItem("menu-scroll-position",document.getElementById("menu").scrollLeft)}</script></body></html>