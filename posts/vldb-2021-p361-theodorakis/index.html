<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>[VLDB 2021] Scabbard: Single-Node Fault-Tolerant Stream Processing | Jian Zhang</title><meta name=keywords content><meta name=description content="这篇论文解决的问题：因为单机磁盘 IO 受限，通常单节点流处理系统的故障恢复依赖于像 kafka 这样的上游分布式系统，使得单节点流处理系统的部署和运维变的非"><meta name=author content="Jian"><link rel=canonical href=https://zz-jason.github.io/posts/vldb-2021-p361-theodorakis/><link href=/assets/css/stylesheet.min.bdb03579c17662815eb277a528f9b9b67a014d2778e9fb0aa5489aa14f7b2643.css integrity="sha256-vbA1ecF2YoFesnelKPm5tnoBTSd46fsKpUiaoU97JkM=" rel="preload stylesheet" as=style><link rel=icon href=https://zz-jason.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://zz-jason.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://zz-jason.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://zz-jason.github.io/apple-touch-icon.png><link rel=mask-icon href=https://zz-jason.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.80.0"><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-67872953-1','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><meta property="og:title" content="[VLDB 2021] Scabbard: Single-Node Fault-Tolerant Stream Processing"><meta property="og:description" content="这篇论文解决的问题：因为单机磁盘 IO 受限，通常单节点流处理系统的故障恢复依赖于像 kafka 这样的上游分布式系统，使得单节点流处理系统的部署和运维变的非"><meta property="og:type" content="article"><meta property="og:url" content="https://zz-jason.github.io/posts/vldb-2021-p361-theodorakis/"><meta property="article:published_time" content="2023-02-19T06:27:23+00:00"><meta property="article:modified_time" content="2023-02-19T06:27:23+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="[VLDB 2021] Scabbard: Single-Node Fault-Tolerant Stream Processing"><meta name=twitter:description content="这篇论文解决的问题：因为单机磁盘 IO 受限，通常单节点流处理系统的故障恢复依赖于像 kafka 这样的上游分布式系统，使得单节点流处理系统的部署和运维变的非"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://zz-jason.github.io/posts/"},{"@type":"ListItem","position":2,"name":"[VLDB 2021] Scabbard: Single-Node Fault-Tolerant Stream Processing","item":"https://zz-jason.github.io/posts/vldb-2021-p361-theodorakis/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"[VLDB 2021] Scabbard: Single-Node Fault-Tolerant Stream Processing","name":"[VLDB 2021] Scabbard: Single-Node Fault-Tolerant Stream Processing","description":"这篇论文解决的问题：因为单机磁盘 IO 受限，通常单节点流处理系统的故障恢复依赖于像 kafka 这样的上游分布式系统，使得单节点流处理系统的部署和运维变的非","keywords":[],"articleBody":"这篇论文解决的问题：因为单机磁盘 IO 受限，通常单节点流处理系统的故障恢复依赖于像 kafka 这样的上游分布式系统，使得单节点流处理系统的部署和运维变的非常复杂。\n due to the limited I/O bandwidth of a single-node, it becomes infeasible to persist all stream data and operator state during execution. Instead, single-node SPEs rely on upstream distributed systems, such as Apache Kafka, to recover stream data after failure, necessitating complex cluster- based deployments.\n 提出的解决办法：基于 operator 的 selectivity 对那些会 discard 数据的 operator 进行落盘，达到降低磁盘 IO 的目的，使得单节点流处理系统能够自己在单机上进行故障恢复。\n Within the operator graph, Scab- bard determines when to persist streams based on the selectivity of operators: by persisting streams after operators that discard data, it can substantially reduce the required I/O bandwidth.\n 流处理系统的应用场景：\n Stream processing enables applications ranging from real-time credit card fraud detection [36] to click-stream analytics [2, 20, 44], and live mining of sensor data [28, 29].\n 分布式流处理系统运维复杂，像 RDMA 这样低延迟高带宽的硬件能力又无法完全在性能上体现出来：\n To accommodate growing data amounts, distributed stream pro- cessing engines (SPEs) such as Flink [19] and Spark Streaming [108] scale out processing to a cluster of nodes through appropriate data partitioning [19, 108] – at substantial operational cost.\nWhile high-speed networking such as RDMA [16, 59] provides 200 Gbps per-port bandwidth with microsecond latencies [11], which allows for fast stream ingestion and remote storage [63], existing cluster-based SPEs cannot saturate these fast interconnects [109].\n 随着硬件规格的提升和新硬件的出现，单机流处理系统的处理能力和处理速度已经能够胜任大多数计算场景。并且因为不再需要考虑分布式处理，单机流计算系统结合 JIT 后相比分布式流计算系统使用更少的资源，运维负担也更低：\n With the rise of parallel hardware, such as multi-core CPUs and GPUs, we witness scale-up designs for single-node SPEs [65, 76, 77, 96, 110] that rival the performance of cluster-based deployments.\nIn contrast, single-node SPEs yield up to an order of magnitude higher per- formance with fewer resources and lower maintenance costs [86]. Such high execution efficiency is achieved by avoiding abstractions for distributed processing and incorporating techniques such as just-in-time (JIT) code generation [47, 96].\n 为什么生产环境中单机流处理系统不多：due to a lack of fault-tolerance mechanisms that guarantee correct results after system failure [6, 53, 94].\n为什么不用分布式流处理系统相同的持久化方式：\n While the same persistence approaches could be used for single- node SPEs, relying on an external cluster-optimized system for persistence, such as Kafka, counteracts the benefits of a single-node deployment.\nA single Kafka node cannot support the performance requirements of modern single-node SPEs.\na single Kafka node can only ingest data streams at rates that are several orders of magnitude lower than LightSaber’s query performance and does not even saturate the SSD bandwidth (indicated by a dashed line). While it is possible to scale out the Kafka deployment to increase its throughput lin- early through stream partitioning, this requires a large cluster (with associated maintenance costs) just to support a single SPE node.\n 前人做过一些尝试，但是发现性能瓶颈出现在了单机的磁盘 IO 上：\n A strawman solution is to design a “self-contained” fault-tole- rance mechanism for a single-node SPE in which the SPE persists all input data streams (and temporary processing state) to stable storage to recover processing after failure. We observe that, for such an approach, disk I/O bandwidth becomes the limiting factor for a majority of queries in Fig. 1, capping performance to 950 MB/s. While I/O bandwidth can be increased through hardware solutions (e.g., NVMe SSDs [106] or RAID [82]), this also increases costs.\n ","wordCount":"855","inLanguage":"en","datePublished":"2023-02-19T06:27:23Z","dateModified":"2023-02-19T06:27:23Z","author":{"@type":"Person","name":"Jian"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://zz-jason.github.io/posts/vldb-2021-p361-theodorakis/"},"publisher":{"@type":"Organization","name":"Jian Zhang","logo":{"@type":"ImageObject","url":"https://zz-jason.github.io/favicon.ico"}}}</script></head><body id=top><noscript><style type=text/css>#theme-toggle,.top-link{display:none}</style></noscript><header class=header><nav class=nav><div class=logo><a href=https://zz-jason.github.io/ accesskey=h title="Jian Zhang (Alt + H)">Jian Zhang</a>
<span class=logo-switches></span></div><ul id=menu onscroll=menu_on_scroll()><li><a href=https://zz-jason.github.io/ title=Home><span>Home</span></a></li><li><a href=https://zz-jason.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://zz-jason.github.io/posts/ title=Archives><span>Archives</span></a></li><li><a href=https://zz-jason.github.io/about/ title=About><span>About</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>[VLDB 2021] Scabbard: Single-Node Fault-Tolerant Stream Processing</h1><div class=post-meta>February 19, 2023&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Jian</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><div class=details>Table of Contents</div></summary><div class=inner></div></details></div><div class=post-content><p>这篇论文解决的问题：因为单机磁盘 IO 受限，通常单节点流处理系统的故障恢复依赖于像 kafka 这样的上游分布式系统，使得单节点流处理系统的部署和运维变的非常复杂。</p><blockquote><p>due to the limited I/O bandwidth of a single-node, it becomes infeasible to persist all stream data and operator state during execution. Instead, single-node SPEs rely on upstream distributed systems, such as Apache Kafka, to recover stream data after failure, necessitating complex cluster- based deployments.</p></blockquote><p>提出的解决办法：基于 operator 的 selectivity 对那些会 discard 数据的 operator 进行落盘，达到降低磁盘 IO 的目的，使得单节点流处理系统能够自己在单机上进行故障恢复。</p><blockquote><p>Within the operator graph, Scab- bard determines when to persist streams based on the selectivity of operators: by persisting streams after operators that discard data, it can substantially reduce the required I/O bandwidth.</p></blockquote><p>流处理系统的应用场景：</p><blockquote><p>Stream processing enables applications ranging from real-time credit card <strong>fraud detection</strong> [36] to <strong>click-stream analytics</strong> [2, 20, 44], and <strong>live mining</strong> of sensor data [28, 29].</p></blockquote><p>分布式流处理系统运维复杂，像 RDMA 这样低延迟高带宽的硬件能力又无法完全在性能上体现出来：</p><blockquote><p>To accommodate growing data amounts, distributed stream pro- cessing engines (SPEs) such as Flink [19] and Spark Streaming [108] scale out processing to a cluster of nodes through appropriate data partitioning [19, 108] – at substantial operational cost.</p><p>While high-speed networking such as RDMA [16, 59] provides 200 Gbps per-port bandwidth with microsecond latencies [11], which allows for fast stream ingestion and remote storage [63], existing cluster-based SPEs cannot saturate these fast interconnects [109].</p></blockquote><p>随着硬件规格的提升和新硬件的出现，单机流处理系统的处理能力和处理速度已经能够胜任大多数计算场景。并且因为不再需要考虑分布式处理，单机流计算系统结合 JIT 后相比分布式流计算系统使用更少的资源，运维负担也更低：</p><blockquote><p>With the rise of parallel hardware, such as multi-core CPUs and GPUs, we witness scale-up designs for single-node SPEs [65, 76, 77, 96, 110] that rival the performance of cluster-based deployments.</p><p>In contrast, single-node SPEs yield up to an order of magnitude higher per- formance with fewer resources and lower maintenance costs [86]. Such high execution efficiency is achieved by avoiding abstractions for distributed processing and incorporating techniques such as just-in-time (JIT) code generation [47, 96].</p></blockquote><p>为什么生产环境中单机流处理系统不多：due to a lack of fault-tolerance mechanisms that guarantee correct results after system failure [6, 53, 94].</p><p><img src=/images/vldb-2021-p361/figure-1.png alt="Figure 1: Data ingestion rates for stream queries in a single-node SPE (LightSaber) vs. a persistent message queue (Apache Kafka)"></p><p>为什么不用分布式流处理系统相同的持久化方式：</p><blockquote><p>While the same persistence approaches could be used for single- node SPEs, relying on an external cluster-optimized system for persistence, such as Kafka, <strong>counteracts the benefits of a single-node deployment</strong>.</p><p>A single Kafka node cannot support the performance requirements of modern single-node SPEs.</p><p>a single Kafka node can only ingest data streams at rates that are several orders of magnitude lower than LightSaber’s query performance and does not even saturate the SSD bandwidth (indicated by a dashed line). While it is possible to scale out the Kafka deployment to increase its throughput lin- early through stream partitioning, <strong>this requires a large cluster (with associated maintenance costs) just to support a single SPE node</strong>.</p></blockquote><p>前人做过一些尝试，但是发现性能瓶颈出现在了单机的磁盘 IO 上：</p><blockquote><p>A strawman solution is to design a “self-contained” fault-tole- rance mechanism for a single-node SPE in which the SPE persists all input data streams (and temporary processing state) to stable storage to recover processing after failure. We observe that, for such an approach, disk I/O bandwidth becomes the limiting factor for a majority of queries in Fig. 1, capping performance to 950 MB/s. While I/O bandwidth can be increased through hardware solutions (e.g., NVMe SSDs [106] or RAID [82]), this also increases costs.</p></blockquote></div><footer class=post-footer><nav class=paginav><a class=prev href=https://zz-jason.github.io/posts/duckdb-query-optimizer/><span class=title>« Prev Page</span><br><span>Duckdb Query Optimizer</span></a>
<a class=next href=https://zz-jason.github.io/posts/sigmod-2001-orthogonal-optimization-of-subqueries-and-aggregation/><span class=title>Next Page »</span><br><span>[SIGMOD 2001] Orthogonal Optimization of Subqueries and Aggregation</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share [VLDB 2021] Scabbard: Single-Node Fault-Tolerant Stream Processing on twitter" href="https://twitter.com/intent/tweet/?text=%5bVLDB%202021%5d%20Scabbard%3a%20Single-Node%20Fault-Tolerant%20Stream%20Processing&url=https%3a%2f%2fzz-jason.github.io%2fposts%2fvldb-2021-p361-theodorakis%2f&hashtags="><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512h-386.892c-34.524.0-62.554-28.03-62.554-62.554v-386.892c0-34.524 28.029-62.554 62.554-62.554h386.892zm-253.927 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share [VLDB 2021] Scabbard: Single-Node Fault-Tolerant Stream Processing on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fzz-jason.github.io%2fposts%2fvldb-2021-p361-theodorakis%2f&title=%5bVLDB%202021%5d%20Scabbard%3a%20Single-Node%20Fault-Tolerant%20Stream%20Processing&summary=%5bVLDB%202021%5d%20Scabbard%3a%20Single-Node%20Fault-Tolerant%20Stream%20Processing&source=https%3a%2f%2fzz-jason.github.io%2fposts%2fvldb-2021-p361-theodorakis%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512h-386.892c-34.524.0-62.554-28.03-62.554-62.554v-386.892c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0v-129.439c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02v-126.056c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768h75.024zm-307.552-334.556c-25.674.0-42.448 16.879-42.448 39.002.0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share [VLDB 2021] Scabbard: Single-Node Fault-Tolerant Stream Processing on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fzz-jason.github.io%2fposts%2fvldb-2021-p361-theodorakis%2f&title=%5bVLDB%202021%5d%20Scabbard%3a%20Single-Node%20Fault-Tolerant%20Stream%20Processing"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512h-386.892c-34.524.0-62.554-28.03-62.554-62.554v-386.892c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zm-119.474 108.193c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zm-160.386-29.702c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share [VLDB 2021] Scabbard: Single-Node Fault-Tolerant Stream Processing on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fzz-jason.github.io%2fposts%2fvldb-2021-p361-theodorakis%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978v-192.915h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554v-386.892c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share [VLDB 2021] Scabbard: Single-Node Fault-Tolerant Stream Processing on whatsapp" href="https://api.whatsapp.com/send?text=%5bVLDB%202021%5d%20Scabbard%3a%20Single-Node%20Fault-Tolerant%20Stream%20Processing%20-%20https%3a%2f%2fzz-jason.github.io%2fposts%2fvldb-2021-p361-theodorakis%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512h-386.892c-34.524.0-62.554-28.03-62.554-62.554v-386.892c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23-13.314-11.876-22.304-26.542-24.916-31.026s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share [VLDB 2021] Scabbard: Single-Node Fault-Tolerant Stream Processing on telegram" href="https://telegram.me/share/url?text=%5bVLDB%202021%5d%20Scabbard%3a%20Single-Node%20Fault-Tolerant%20Stream%20Processing&url=https%3a%2f%2fzz-jason.github.io%2fposts%2fvldb-2021-p361-theodorakis%2f"><svg viewBox="2 2 28 28"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47A3.38 3.38.0 0126.49 29.86zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer><script src=https://utteranc.es/client.js repo=zz-jason/zz-jason.github.io issue-term=pathname theme=github-light crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2023 <a href=https://zz-jason.github.io/>Jian Zhang</a></span>
<span>&#183;</span>
<span>Powered by <a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a></span>
<span>&#183;</span>
<span>Theme <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)"><button class=top-link id=top-link type=button accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></button></a>
<script defer src=/assets/js/highlight.min.27cd435cc9ed6abb4b496581b151804f79f366c412620272bb94e2f5f598ebcc.js integrity="sha256-J81DXMntartLSWWBsVGAT3nzZsQSYgJyu5Ti9fWY68w=" onload=hljs.initHighlightingOnLoad();></script><script>window.onload=function(){if(localStorage.getItem("menu-scroll-position")){document.getElementById('menu').scrollLeft=localStorage.getItem("menu-scroll-position");}}
document.querySelectorAll('a[href^="#"]').forEach(anchor=>{anchor.addEventListener("click",function(e){e.preventDefault();var id=this.getAttribute("href").substr(1);if(!window.matchMedia('(prefers-reduced-motion: reduce)').matches){document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({behavior:"smooth"});}else{document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();}
if(id==="top"){history.replaceState(null,null," ");}else{history.pushState(null,null,`#${id}`);}});});var mybutton=document.getElementById("top-link");window.onscroll=function(){if(document.body.scrollTop>800||document.documentElement.scrollTop>800){mybutton.style.visibility="visible";mybutton.style.opacity="1";}else{mybutton.style.visibility="hidden";mybutton.style.opacity="0";}};function menu_on_scroll(){localStorage.setItem("menu-scroll-position",document.getElementById('menu').scrollLeft);}</script></body></html>